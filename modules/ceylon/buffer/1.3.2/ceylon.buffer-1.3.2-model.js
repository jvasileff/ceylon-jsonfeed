(function(define) { define(function(require, ex$, module) {
ex$.$CCMM$={"ceylon.buffer.readers":{Reader:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,mt:"c",an:[{doc:["Represents an object that can read data from a source\ninto byte buffers."]},{by:["Stéphane Épardaud"]}],$m:{read:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",an:[{doc:["Reads data into the given [[buffer]] and returns the\nnumber of bytes read, or `-1` if the end of the file is\nreached."]}],ps:[[{$t:{pk:"ceylon.buffer",nm:"ByteBuffer"},mt:"prm",nm:"buffer"}]],nm:"read"},readByteArray:{$t:{md:"$",pk:"$",nm:"Integer"},pa:9,mt:"m",an:[{doc:["Reads data into the given [[byte array|array]] and\nreturns the number of bytes read, or `-1` if the end of\nthe file is reached."]}],ps:[[{$t:{md:"$",ta:{"Array.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Array"},mt:"prm",nm:"array"}]],nm:"readByteArray"},readByte:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Byte"}]},pa:9,mt:"m",an:[{doc:["Reads a single byte. Returns the byte read, or `null`\nat the end of the file. \n\nThis method blocks the current thread until a byte is\nread or end of file is reached, so if the underlying\nreader is non-blocking then this method will do very\nexpensive active polling."]}],nm:"readByte"}},$at:{buffer$b77h7h:{$t:{pk:"ceylon.buffer",nm:"ByteBuffer"},mt:"a",nm:"buffer"},byteBuffer$y9phdn:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.buffer",nm:"ByteBuffer"}]},pa:1024,mt:"a",nm:"byteBuffer"}},nm:"Reader"},readByteArray:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",ps:[[{$t:{md:"$",ta:{"Array.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Array"},mt:"prm",nm:"array"},{$t:{pk:".",nm:"Reader"},mt:"prm",nm:"reader"}]],nm:"readByteArray"},"$pkg-pa":1},"$mod-deps":["ceylon.language\/1.3.2","ceylon.collection\/1.3.2"],"$mod-name":"ceylon.buffer","$mod-version":"1.3.2","$mod-anns":[{doc:["\nThis module allows you to convert between text and binary forms of data.\n\nFor efficiency of I\/O (see the `ceylon.io` module), [[Buffer]]s are the core\nrepresentation which [[ceylon.buffer.codec::Codec]]s output from the\nencode\/decode operations, but it's still easy to get more general types like\n[[Array]]s and [[String]]s. Input to the operations can be any stream type.\n\n[[ceylon.buffer.codec::Codec]]s are symmetrical, as any data that is\n[[encode|ceylon.buffer.codec::StatelessCodec.encode]]d then\n[[decode|ceylon.buffer.codec::StatelessCodec.decode]]d (or vice versa) with\nthe same codec will be at least semantically equivalent to the starting\ndata, and usually exactly equal.\n\n[[ceylon.buffer.codec::Codec]]s come in four flavours:\n[[ByteToByte|ceylon.buffer.codec::ByteToByteCodec]],\n[[ByteToCharacter|ceylon.buffer.codec::ByteToCharacterCodec]],\n[[CharacterToByte|ceylon.buffer.codec::CharacterToByteCodec]], and\n[[CharacterToCharacter|ceylon.buffer.codec::CharacterToCharacterCodec]]. The\nmiddle two are similar, yet kept seperate to support differing conventions\naround what `encode` and `decode` mean in particular codec families. To\nenhance efficiency, `ByteToByteCodec`s are offered as variants of some\n`CharacterToByteCodec`s where the `Character` form is comprised of ASCII\ncharacters only. These variants' output is the same as using the original\nplus encoding the characters with the [[ASCII|ceylon.buffer.charset::ascii]]\ncharset.\n\nThere are three currently implemented codec families:\n[[charsets|package ceylon.buffer.charset]]\n([[UTF-8|ceylon.buffer.charset::utf8]] for example),\n[[base encodings|package ceylon.buffer.base]] (like\n[[base64|ceylon.buffer.base::base64ByteStandard]]), and\n[[text ciphers|package ceylon.buffer.text]]\n([[rot13|ceylon.buffer.text::rot13]] for example). See those packages for\nfurther documentation and examples of use."]},{by:["Stéphane Épardaud","Alex Szczuczko"]}],"ceylon.buffer.codec":{ByteToCharacterCodec:{pa:1,mt:"i",an:[{doc:["Common interface for Codecs that convert between bytes and characters.\nExamples: utf8, ascii."]}],sts:[{ta:{"IncrementalCodec.ToImmutable":{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},"IncrementalCodec.ToMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"},"IncrementalCodec.ToSingle":{md:"$",pk:"$",nm:"Byte"},"IncrementalCodec.FromSingle":{md:"$",pk:"$",nm:"Character"},"IncrementalCodec.FromImmutable":{md:"$",pk:"$",nm:"String"},"IncrementalCodec.FromMutable":{pk:"ceylon.buffer",nm:"CharacterBuffer"}},pk:".",nm:"IncrementalCodec"}],$m:{encode:{$t:{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"encode"},decode:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"decode"},cumulativeDecoder:{$t:{ta:{"CumulativeConvert.ToSingle":{md:"$",pk:"$",nm:"Character"},"CumulativeConvert.FromImmutable":{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},"CumulativeConvert.ToMutable":{pk:"ceylon.buffer",nm:"CharacterBuffer"},"CumulativeConvert.FromSingle":{md:"$",pk:"$",nm:"Byte"}},pk:".",nm:"CumulativeConvert"},pa:3,mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},def:1,mt:"prm",nm:"inputSize"},{$t:{md:"$",pk:"$",nm:"Float"},def:1,mt:"prm",nm:"growthFactor"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"cumulativeDecoder"},decodeBuffer:{$t:{pk:"ceylon.buffer",nm:"CharacterBuffer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"decodeBuffer"},encodeBuffer:{$t:{pk:"ceylon.buffer",nm:"ByteBuffer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"encodeBuffer"},cumulativeEncoder:{$t:{ta:{"CumulativeConvert.ToSingle":{md:"$",pk:"$",nm:"Byte"},"CumulativeConvert.FromImmutable":{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},"CumulativeConvert.ToMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"},"CumulativeConvert.FromSingle":{md:"$",pk:"$",nm:"Character"}},pk:".",nm:"CumulativeConvert"},pa:3,mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},def:1,mt:"prm",nm:"inputSize"},{$t:{md:"$",pk:"$",nm:"Float"},def:1,mt:"prm",nm:"growthFactor"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"cumulativeEncoder"}},nm:"ByteToCharacterCodec"},DecodeException:{super:{pk:".",nm:"ConvertException"},pa:1,mt:"c",an:[{doc:["Thrown by failed decode operations"]}],$at:{cause$3mqy1e:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},mt:"a",nm:"cause"},description$igo2ct:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},mt:"a",nm:"description"}},ps:[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},def:1,mt:"prm",$hdn:1,nm:"description"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},def:1,mt:"prm",$hdn:1,nm:"cause"}],nm:"DecodeException"},capitalizations:{$t:{md:"$",ta:{"Set.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Set"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"base"}]],nm:"capitalizations"},convertBuffer:{$t:{nm:"Buf"},mt:"m",tp:[{sts:[{ta:{"Buffer.Element":{nm:"To"}},pk:"ceylon.buffer",nm:"Buffer"}],nm:"Buf"},{nm:"To"},{nm:"From"}],$m:{add$wcpndl:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",ps:[[{$t:{nm:"To"},mt:"prm",nm:"element"}]],nm:"add"}},ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"From"}},pk:"$",nm:"Iterable"},mt:"prm",$hdn:1,nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},mt:"prm",$hdn:1,nm:"error"},{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{pk:".",nm:"ErrorStrategy"},pk:"$",nm:"Tuple"},"Callable.Return":{ta:{"PieceConvert.FromSingle":{nm:"From"},"PieceConvert.ToSingle":{nm:"To"}},pk:".",nm:"PieceConvert"}},pk:"$",nm:"Callable"},mt:"prm",$hdn:1,nm:"converter"},{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},"Callable.Return":{nm:"Buf"}},pk:"$",nm:"Callable"},mt:"prm",$hdn:1,nm:"ofSize"},{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},"Callable.Return":{md:"$",pk:"$",nm:"Integer"}},pk:"$",nm:"Callable"},mt:"prm",$hdn:1,nm:"averageSize"},{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},"Callable.Return":{md:"$",pk:"$",nm:"Integer"}},pk:"$",nm:"Callable"},mt:"prm",$hdn:1,nm:"maximumSize"}]],nm:"convertBuffer"},buildAuction:{$t:{md:"$",ta:{"Sequential.Element":{ta:{"IncrementalCodec.ToImmutable":{nm:"ToImmutable"},"IncrementalCodec.ToMutable":{nm:"ToMutable"},"IncrementalCodec.ToSingle":{nm:"ToSingle"},"IncrementalCodec.FromSingle":{nm:"FromSingle"},"IncrementalCodec.FromImmutable":{nm:"FromImmutable"},"IncrementalCodec.FromMutable":{nm:"FromMutable"}},pk:".",nm:"IncrementalCodec"}},pk:"$",nm:"Sequential"},pa:1,mt:"m",tp:[{nm:"ToMutable"},{nm:"ToImmutable"},{nm:"ToSingle"},{nm:"FromMutable"},{nm:"FromImmutable"},{nm:"FromSingle"}],ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{pk:"$",nm:"Nothing"},"Iterable.Element":{ta:{"IncrementalCodec.ToImmutable":{nm:"ToImmutable"},"IncrementalCodec.ToMutable":{nm:"ToMutable"},"IncrementalCodec.ToSingle":{nm:"ToSingle"},"IncrementalCodec.FromSingle":{nm:"FromSingle"},"IncrementalCodec.FromImmutable":{nm:"FromImmutable"},"IncrementalCodec.FromMutable":{nm:"FromMutable"}},pk:".",nm:"IncrementalCodec"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"bidders"}],[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"FromSingle"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"lot"}]],nm:"buildAuction"},ByteToByteCodec:{pa:1,mt:"i",an:[{doc:["Common interface for Codecs that convert between bytes and bytes. Examples:\ngzip, and base64."]}],sts:[{ta:{"IncrementalCodec.ToImmutable":{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},"IncrementalCodec.ToMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"},"IncrementalCodec.ToSingle":{md:"$",pk:"$",nm:"Byte"},"IncrementalCodec.FromSingle":{md:"$",pk:"$",nm:"Byte"},"IncrementalCodec.FromImmutable":{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},"IncrementalCodec.FromMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"}},pk:".",nm:"IncrementalCodec"}],$m:{encode:{$t:{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"encode"},decode:{$t:{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"decode"},cumulativeDecoder:{$t:{ta:{"CumulativeConvert.ToSingle":{md:"$",pk:"$",nm:"Byte"},"CumulativeConvert.FromImmutable":{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},"CumulativeConvert.ToMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"},"CumulativeConvert.FromSingle":{md:"$",pk:"$",nm:"Byte"}},pk:".",nm:"CumulativeConvert"},pa:3,mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},def:1,mt:"prm",nm:"inputSize"},{$t:{md:"$",pk:"$",nm:"Float"},def:1,mt:"prm",nm:"growthFactor"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"cumulativeDecoder"},decodeBuffer:{$t:{pk:"ceylon.buffer",nm:"ByteBuffer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"decodeBuffer"},encodeBuffer:{$t:{pk:"ceylon.buffer",nm:"ByteBuffer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"encodeBuffer"},cumulativeEncoder:{$t:{ta:{"CumulativeConvert.ToSingle":{md:"$",pk:"$",nm:"Byte"},"CumulativeConvert.FromImmutable":{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},"CumulativeConvert.ToMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"},"CumulativeConvert.FromSingle":{md:"$",pk:"$",nm:"Byte"}},pk:".",nm:"CumulativeConvert"},pa:3,mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},def:1,mt:"prm",nm:"inputSize"},{$t:{md:"$",pk:"$",nm:"Float"},def:1,mt:"prm",nm:"growthFactor"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"cumulativeEncoder"}},nm:"ByteToByteCodec"},EncodeException:{super:{pk:".",nm:"ConvertException"},pa:1,mt:"c",an:[{doc:["Thrown by failed encode operations"]}],$at:{cause$gu6pp2:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},mt:"a",nm:"cause"},description$209ldn:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},mt:"a",nm:"description"}},ps:[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},def:1,mt:"prm",$hdn:1,nm:"description"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},def:1,mt:"prm",$hdn:1,nm:"cause"}],nm:"EncodeException"},CumulativeConvert:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["Convert into a new buffer as portions arrive and return the buffer when the\ninput is complete."]}],tp:[{sts:[{ta:{"Buffer.Element":{nm:"ToSingle"}},pk:"ceylon.buffer",nm:"Buffer"}],nm:"ToMutable"},{sts:[{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"FromSingle"}},pk:"$",nm:"Iterable"}],nm:"FromImmutable"},{nm:"ToSingle"},{nm:"FromSingle"}],$m:{more:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:1,mt:"m",ps:[[{$t:{nm:"FromImmutable"},mt:"prm",nm:"input"}]],nm:"more"},done:{$t:{nm:"ToMutable"},pa:1,mt:"m",nm:"done"},add$gngmgx:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",ps:[[{$t:{nm:"ToSingle"},mt:"prm",nm:"element"}]],nm:"add"}},$at:{pieceConverter$q3tx2u:{$t:{ta:{"PieceConvert.FromSingle":{nm:"FromSingle"},"PieceConvert.ToSingle":{nm:"ToSingle"}},pk:".",nm:"PieceConvert"},mt:"a",nm:"pieceConverter"},error$3sl85s:{$t:{pk:".",nm:"ErrorStrategy"},mt:"a",nm:"error"},growthFactor$p0z836:{$t:{md:"$",pk:"$",nm:"Float"},mt:"a",nm:"growthFactor"},output$l7clb3:{$t:{nm:"ToMutable"},mt:"a",nm:"output"},inputSize$jvxoqj:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},mt:"a",nm:"inputSize"},averageSize$tqq6s6:{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},"Callable.Return":{md:"$",pk:"$",nm:"Integer"}},pk:"$",nm:"Callable"},mt:"a",nm:"averageSize"},converter$j9f2jc:{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{pk:".",nm:"ErrorStrategy"},pk:"$",nm:"Tuple"},"Callable.Return":{ta:{"PieceConvert.FromSingle":{nm:"FromSingle"},"PieceConvert.ToSingle":{nm:"ToSingle"}},pk:".",nm:"PieceConvert"}},pk:"$",nm:"Callable"},mt:"a",nm:"converter"},sizeOf$jm0egw:{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},"Callable.Return":{nm:"ToMutable"}},pk:"$",nm:"Callable"},mt:"a",nm:"sizeOf"}},ps:[{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{pk:".",nm:"ErrorStrategy"},pk:"$",nm:"Tuple"},"Callable.Return":{ta:{"PieceConvert.FromSingle":{nm:"FromSingle"},"PieceConvert.ToSingle":{nm:"ToSingle"}},pk:".",nm:"PieceConvert"}},pk:"$",nm:"Callable"},mt:"prm",$hdn:1,nm:"converter"},{$t:{pk:".",nm:"ErrorStrategy"},mt:"prm",$hdn:1,nm:"error"},{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},"Callable.Return":{nm:"ToMutable"}},pk:"$",nm:"Callable"},mt:"prm",$hdn:1,nm:"sizeOf"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},mt:"prm",$hdn:1,nm:"inputSize"},{$t:{md:"$",pk:"$",nm:"Float"},mt:"prm",$hdn:1,nm:"growthFactor"},{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},"Callable.Return":{md:"$",pk:"$",nm:"Integer"}},pk:"$",nm:"Callable"},mt:"prm",$hdn:1,nm:"averageSize"}],nm:"CumulativeConvert"},IncrementalCodec:{pa:1,mt:"i",an:[{doc:["Codecs that can process input into output in portions of the whole."]}],sts:[{ta:{"StatelessCodec.FromSingle":{nm:"FromSingle"},"StatelessCodec.FromMutable":{nm:"FromMutable"},"StatelessCodec.ToMutable":{nm:"ToMutable"},"StatelessCodec.ToSingle":{nm:"ToSingle"},"StatelessCodec.FromImmutable":{nm:"FromImmutable"},"StatelessCodec.ToImmutable":{nm:"ToImmutable"}},pk:".",nm:"StatelessCodec"}],tp:[{sts:[{ta:{"Buffer.Element":{nm:"ToSingle"}},pk:"ceylon.buffer",nm:"Buffer"}],nm:"ToMutable"},{sts:[{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"}],nm:"ToImmutable"},{nm:"ToSingle"},{sts:[{ta:{"Buffer.Element":{nm:"FromSingle"}},pk:"ceylon.buffer",nm:"Buffer"}],nm:"FromMutable"},{sts:[{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"FromSingle"}},pk:"$",nm:"Iterable"}],nm:"FromImmutable"},{nm:"FromSingle"}],$m:{decodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",an:[{doc:["The certainty that that the given [[sample]] is suitable for decoding with\nthis codec.\n\nA number 1 or greater indicates that (based on the sample at\nleast) the input should decode without error. The higher the number is\nbeyond 1, the more appropriate this codec is likely to be."]}],ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"decodeBid"},chunkEncoder:{$t:{ta:{"ChunkConvert.ToSingle":{nm:"ToSingle"},"ChunkConvert.FromSingle":{nm:"FromSingle"},"ChunkConvert.ToMutable":{nm:"ToMutable"}},pk:".",nm:"ChunkConvert"},pa:1,mt:"m",an:[{doc:["Encodes in portions dictated by the size of the output buffer, which will\nnot be resized."]},{throws:["EncodeException","When an error is encountered and [[error]] == [[strict]]"]}],ps:[[{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"chunkEncoder"},chunkDecoder:{$t:{ta:{"ChunkConvert.ToSingle":{nm:"FromSingle"},"ChunkConvert.FromSingle":{nm:"ToSingle"},"ChunkConvert.ToMutable":{nm:"FromMutable"}},pk:".",nm:"ChunkConvert"},pa:1,mt:"m",an:[{doc:["Decodes in portions dictated by the size of the output buffer, which will\nnot be resized."]},{throws:["DecodeException","When an error is encountered and [[error]] == [[strict]]"]}],ps:[[{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"chunkDecoder"},pieceDecoder:{$t:{ta:{"PieceConvert.FromSingle":{nm:"ToSingle"},"PieceConvert.ToSingle":{nm:"FromSingle"}},pk:".",nm:"PieceConvert"},pa:5,mt:"m",an:[{doc:["Decodes one output piece to zero or more input pieces. This is mostly\nintended for refinement by subtypes. Higher level decode methods are\nprovided for general use."]},{throws:["DecodeException","When an error is encountered and [[error]] == [[strict]]"]}],ps:[[{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceDecoder"},cumulativeDecoder:{$t:{ta:{"CumulativeConvert.ToSingle":{nm:"FromSingle"},"CumulativeConvert.FromImmutable":{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"},"CumulativeConvert.ToMutable":{nm:"FromMutable"},"CumulativeConvert.FromSingle":{nm:"ToSingle"}},pk:".",nm:"CumulativeConvert"},pa:5,mt:"m",an:[{doc:["Decode into a new buffer as portions arrive and return the buffer when the\ninput is complete. [[inputSize]] can be used to hint the expected total\nsize of the input, to avoid resizing the output buffer unnecessarily."]}],ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},def:1,mt:"prm",nm:"inputSize"},{$t:{md:"$",pk:"$",nm:"Float"},def:1,mt:"prm",nm:"growthFactor"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"cumulativeDecoder"},cumulativeEncoder:{$t:{ta:{"CumulativeConvert.ToSingle":{nm:"ToSingle"},"CumulativeConvert.FromImmutable":{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"FromSingle"}},pk:"$",nm:"Iterable"},"CumulativeConvert.ToMutable":{nm:"ToMutable"},"CumulativeConvert.FromSingle":{nm:"FromSingle"}},pk:".",nm:"CumulativeConvert"},pa:5,mt:"m",an:[{doc:["Encode into a new buffer as portions arrive and return the buffer when the\ninput is complete. [[inputSize]] can be used to hint the expected total\nsize of the input, to avoid resizing the output buffer unnecessarily."]}],ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},def:1,mt:"prm",nm:"inputSize"},{$t:{md:"$",pk:"$",nm:"Float"},def:1,mt:"prm",nm:"growthFactor"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"cumulativeEncoder"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",an:[{doc:["The certainty that that the given [[sample]] is suitable for encoding with\nthis codec.\n\nA number 1 or greater indicates that (based on the sample at\nleast) the input should encode without error. The higher the number is\nbeyond 1, the more appropriate this codec is likely to be."]}],ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"FromSingle"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"},pieceEncoder:{$t:{ta:{"PieceConvert.FromSingle":{nm:"FromSingle"},"PieceConvert.ToSingle":{nm:"ToSingle"}},pk:".",nm:"PieceConvert"},pa:5,mt:"m",an:[{doc:["Encodes one input piece to zero or more output pieces. This is mostly\nintended for refinement by subtypes. Higher level encode methods are\nprovided for general use."]},{throws:["EncodeException","When an error is encountered and [[error]] == [[strict]]"]}],ps:[[{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceEncoder"}},nm:"IncrementalCodec"},ChunkConvert:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",tp:[{sts:[{ta:{"Buffer.Element":{nm:"ToSingle"}},pk:"ceylon.buffer",nm:"Buffer"}],nm:"ToMutable"},{nm:"ToSingle"},{nm:"FromSingle"}],$m:{convertToSingle:{$t:{comp:"u",l:[{nm:"ToSingle"},{md:"$",pk:"$",nm:"Finished"}]},pa:1,mt:"m",ps:[[{$t:{md:"$",ta:{"Callable.Arguments":{md:"$",pk:"$",nm:"Empty"},"Callable.Return":{comp:"u",l:[{nm:"FromSingle"},{md:"$",pk:"$",nm:"Finished"}]}},pk:"$",nm:"Callable"},mt:"prm",nm:"provider"}]],nm:"convertToSingle"},convert:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Converts in portions dictated by the size of the output buffer, which will\nnot be resized.\n\nThe return value is the number of input units read during the call."]}],ps:[[{$t:{nm:"ToMutable"},mt:"prm",nm:"output"},{$t:{md:"$",ta:{"Callable.Arguments":{md:"$",pk:"$",nm:"Empty"},"Callable.Return":{comp:"u",l:[{nm:"FromSingle"},{md:"$",pk:"$",nm:"Finished"}]}},pk:"$",nm:"Callable"},mt:"prm",nm:"provider"},{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",an:[{doc:["`true` if the given [[provider]] contains all remaining\ninput that will be fed to this `ChunkConverter`"]}],nm:"endOfInput"}]],nm:"convert"}},$at:{pieceConverter$8mz4ao:{$t:{ta:{"PieceConvert.FromSingle":{nm:"FromSingle"},"PieceConvert.ToSingle":{nm:"ToSingle"}},pk:".",nm:"PieceConvert"},mt:"a",nm:"pieceConverter"},remainder$3p12xx:{$t:{md:"ceylon.collection",ta:{"LinkedList.Element":{nm:"ToSingle"}},pk:"ceylon.collection",nm:"LinkedList"},mt:"a",nm:"remainder"},converter$fhdyu6:{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{pk:".",nm:"ErrorStrategy"},pk:"$",nm:"Tuple"},"Callable.Return":{ta:{"PieceConvert.FromSingle":{nm:"FromSingle"},"PieceConvert.ToSingle":{nm:"ToSingle"}},pk:".",nm:"PieceConvert"}},pk:"$",nm:"Callable"},mt:"a",nm:"converter"},error$whpsfu:{$t:{pk:".",nm:"ErrorStrategy"},mt:"a",nm:"error"}},ps:[{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{pk:".",nm:"ErrorStrategy"},pk:"$",nm:"Tuple"},"Callable.Return":{ta:{"PieceConvert.FromSingle":{nm:"FromSingle"},"PieceConvert.ToSingle":{nm:"ToSingle"}},pk:".",nm:"PieceConvert"}},pk:"$",nm:"Callable"},mt:"prm",$hdn:1,nm:"converter"},{$t:{pk:".",nm:"ErrorStrategy"},mt:"prm",$hdn:1,nm:"error"}],nm:"ChunkConvert"},CharacterToCharacterCodec:{pa:1,mt:"i",an:[{doc:["Common interface for Codecs that convert between characters and characters.\nExamples: rot13."]}],sts:[{ta:{"IncrementalCodec.ToImmutable":{md:"$",pk:"$",nm:"String"},"IncrementalCodec.ToMutable":{pk:"ceylon.buffer",nm:"CharacterBuffer"},"IncrementalCodec.ToSingle":{md:"$",pk:"$",nm:"Character"},"IncrementalCodec.FromSingle":{md:"$",pk:"$",nm:"Character"},"IncrementalCodec.FromImmutable":{md:"$",pk:"$",nm:"String"},"IncrementalCodec.FromMutable":{pk:"ceylon.buffer",nm:"CharacterBuffer"}},pk:".",nm:"IncrementalCodec"}],$m:{encode:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"encode"},decode:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"decode"},cumulativeDecoder:{$t:{ta:{"CumulativeConvert.ToSingle":{md:"$",pk:"$",nm:"Character"},"CumulativeConvert.FromImmutable":{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},"CumulativeConvert.ToMutable":{pk:"ceylon.buffer",nm:"CharacterBuffer"},"CumulativeConvert.FromSingle":{md:"$",pk:"$",nm:"Character"}},pk:".",nm:"CumulativeConvert"},pa:3,mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},def:1,mt:"prm",nm:"inputSize"},{$t:{md:"$",pk:"$",nm:"Float"},def:1,mt:"prm",nm:"growthFactor"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"cumulativeDecoder"},decodeBuffer:{$t:{pk:"ceylon.buffer",nm:"CharacterBuffer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"decodeBuffer"},encodeBuffer:{$t:{pk:"ceylon.buffer",nm:"CharacterBuffer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"encodeBuffer"},cumulativeEncoder:{$t:{ta:{"CumulativeConvert.ToSingle":{md:"$",pk:"$",nm:"Character"},"CumulativeConvert.FromImmutable":{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},"CumulativeConvert.ToMutable":{pk:"ceylon.buffer",nm:"CharacterBuffer"},"CumulativeConvert.FromSingle":{md:"$",pk:"$",nm:"Character"}},pk:".",nm:"CumulativeConvert"},pa:3,mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},def:1,mt:"prm",nm:"inputSize"},{$t:{md:"$",pk:"$",nm:"Float"},def:1,mt:"prm",nm:"growthFactor"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"cumulativeEncoder"}},nm:"CharacterToCharacterCodec"},ErrorStrategy:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"strict"},{pk:".",nm:"ignore"},{pk:".",nm:"reset"}],pa:257,mt:"c",an:[{doc:["Action to take when an error is encountered during encoding or decoding."]}],nm:"ErrorStrategy"},Codec:{pa:1,mt:"i",$m:{averageDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",an:[{doc:["Estimate an initial output buffer size that balances memory conservation\nwith the risk of a resize for decoding operations."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageDecodeSize"},averageEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",an:[{doc:["Estimate an initial output buffer size that balances memory conservation\nwith the risk of a resize for encoding operations."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageEncodeSize"},maximumEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",an:[{doc:["Determine the largest size an encoding output buffer needs to be."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumEncodeSize"},maximumDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",an:[{doc:["Determine the largest size an decoding output buffer needs to be."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumDecodeSize"}},$at:{name:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"g",an:[{doc:["The alias most commonly used for this codec, or otherwise specified by a\nstandard."]}],nm:"name"},aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:5,mt:"a",an:[{doc:["A list of common names. The first alias is [[name]]."]}],nm:"aliases"}},nm:"Codec"},CharacterToByteCodec:{pa:1,mt:"i",an:[{doc:["Common interface for Codecs that convert between characters and bytes.\nExamples: base64."]}],sts:[{ta:{"IncrementalCodec.ToImmutable":{md:"$",pk:"$",nm:"String"},"IncrementalCodec.ToMutable":{pk:"ceylon.buffer",nm:"CharacterBuffer"},"IncrementalCodec.ToSingle":{md:"$",pk:"$",nm:"Character"},"IncrementalCodec.FromSingle":{md:"$",pk:"$",nm:"Byte"},"IncrementalCodec.FromImmutable":{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},"IncrementalCodec.FromMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"}},pk:".",nm:"IncrementalCodec"}],$m:{encode:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"encode"},decode:{$t:{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"decode"},cumulativeDecoder:{$t:{ta:{"CumulativeConvert.ToSingle":{md:"$",pk:"$",nm:"Byte"},"CumulativeConvert.FromImmutable":{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},"CumulativeConvert.ToMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"},"CumulativeConvert.FromSingle":{md:"$",pk:"$",nm:"Character"}},pk:".",nm:"CumulativeConvert"},pa:3,mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},def:1,mt:"prm",nm:"inputSize"},{$t:{md:"$",pk:"$",nm:"Float"},def:1,mt:"prm",nm:"growthFactor"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"cumulativeDecoder"},decodeBuffer:{$t:{pk:"ceylon.buffer",nm:"ByteBuffer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"decodeBuffer"},encodeBuffer:{$t:{pk:"ceylon.buffer",nm:"CharacterBuffer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"encodeBuffer"},cumulativeEncoder:{$t:{ta:{"CumulativeConvert.ToSingle":{md:"$",pk:"$",nm:"Character"},"CumulativeConvert.FromImmutable":{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},"CumulativeConvert.ToMutable":{pk:"ceylon.buffer",nm:"CharacterBuffer"},"CumulativeConvert.FromSingle":{md:"$",pk:"$",nm:"Byte"}},pk:".",nm:"CumulativeConvert"},pa:3,mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},def:1,mt:"prm",nm:"inputSize"},{$t:{md:"$",pk:"$",nm:"Float"},def:1,mt:"prm",nm:"growthFactor"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"cumulativeEncoder"}},nm:"CharacterToByteCodec"},PieceConvert:{pa:1,mt:"i",an:[{doc:["Converts single pieces of input into output pieces"]}],tp:[{nm:"ToSingle"},{nm:"FromSingle"}],$m:{more:{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"},pa:5,mt:"m",ps:[[{$t:{nm:"FromSingle"},mt:"prm",nm:"input"}]],nm:"more"},done:{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"},pa:9,mt:"m",nm:"done"}},nm:"PieceConvert"},ConvertException:{super:{md:"$",pk:"$",nm:"Exception"},pa:1,mt:"c",an:[{doc:["Thrown by failed conversion operations"]}],$at:{description$yegb8g:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},mt:"a",nm:"description"},cause$lsqmf9:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},mt:"a",nm:"cause"}},ps:[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},def:1,mt:"prm",$hdn:1,nm:"description"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},def:1,mt:"prm",$hdn:1,nm:"cause"}],nm:"ConvertException"},asd:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",nm:"asd"},StatelessCodec:{pa:1,mt:"i",an:[{doc:["Codecs that can take an input all at once, and return the output all at once."]}],sts:[{pk:".",nm:"Codec"}],tp:[{sts:[{ta:{"Buffer.Element":{nm:"ToSingle"}},pk:"ceylon.buffer",nm:"Buffer"}],nm:"ToMutable"},{sts:[{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"}],nm:"ToImmutable"},{nm:"ToSingle"},{sts:[{ta:{"Buffer.Element":{nm:"FromSingle"}},pk:"ceylon.buffer",nm:"Buffer"}],nm:"FromMutable"},{sts:[{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"FromSingle"}},pk:"$",nm:"Iterable"}],nm:"FromImmutable"},{nm:"FromSingle"}],$m:{encode:{$t:{nm:"ToImmutable"},pa:5,mt:"m",an:[{doc:["Encode all of [[input]], returning all of the output."]},{throws:["EncodeException","When an error is encountered and [[error]] == [[strict]]"]}],ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"FromSingle"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"encode"},decode:{$t:{nm:"FromImmutable"},pa:5,mt:"m",an:[{doc:["Decode all of [[input]], returning all of the output."]},{throws:["DecodeException","When an error is encountered and [[error]] == [[strict]]"]}],ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"decode"},decodeBuffer:{$t:{nm:"FromMutable"},pa:5,mt:"m",an:[{doc:["Decode all of [[input]] into a new buffer and return it."]},{throws:["DecodeException","When an error is encountered and [[error]] == [[strict]]"]}],ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"decodeBuffer"},encodeBuffer:{$t:{nm:"ToMutable"},pa:5,mt:"m",an:[{doc:["Encode all of [[input]] into a new buffer and return it."]},{throws:["EncodeException","When an error is encountered and [[error]] == [[strict]]"]}],ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"FromSingle"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"input"},{$t:{pk:".",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"encodeBuffer"}},nm:"StatelessCodec"},reset:{super:{pk:".",nm:"ErrorStrategy"},pa:1,mt:"o",an:[{doc:["Reset the internal state, then continue without throwing an exception"]}],nm:"reset"},strict:{super:{pk:".",nm:"ErrorStrategy"},pa:1,mt:"o",an:[{doc:["Throw a [[ConvertException]]"]}],nm:"strict"},"$pkg-pa":1,"$pkg-anns":[{doc:["\nThis package contains the infrastructure of the [[Codec]] system.\n\nThose wanting to implement their own codecs should refine one of the four\ncodec flavours: [[ByteToByteCodec]], [[ByteToCharacterCodec]],\n[[CharacterToByteCodec]], and [[CharacterToCharacterCodec]]."]}],buildCodecLookup:{$t:{md:"$",ta:{"Map.Item":{nm:"CodecOrLower"},"Map.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Map"},pa:1,mt:"m",tp:[{sts:[{pk:".",nm:"Codec"}],nm:"CodecOrLower"}],ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"CodecOrLower"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"codecs"}]],nm:"buildCodecLookup"},auctionByteToByteEncode:{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},pk:"$",nm:"Tuple"},"Callable.Return":{md:"$",ta:{"Sequential.Element":{ta:{"IncrementalCodec.ToImmutable":{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},"IncrementalCodec.ToMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"},"IncrementalCodec.ToSingle":{md:"$",pk:"$",nm:"Byte"},"IncrementalCodec.FromSingle":{md:"$",pk:"$",nm:"Byte"},"IncrementalCodec.FromImmutable":{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},"IncrementalCodec.FromMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"}},pk:".",nm:"IncrementalCodec"}},pk:"$",nm:"Sequential"}},pk:"$",nm:"Callable"},pa:1,mt:"a",nm:"auctionByteToByteEncode"},ignore:{super:{pk:".",nm:"ErrorStrategy"},pa:1,mt:"o",an:[{doc:["Continue without throwing an exception"]}],nm:"ignore"}},"ceylon.buffer":{BufferUnderflowException:{super:{pk:".",nm:"BufferException"},pa:1,mt:"c",$at:{cause$obyiz2:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},mt:"a",nm:"cause"},description$9i1enn:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},mt:"a",nm:"description"}},ps:[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},def:1,mt:"prm",$hdn:1,nm:"description"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},def:1,mt:"prm",$hdn:1,nm:"cause"}],nm:"BufferUnderflowException"},resizeBuffer:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",tp:[{nm:"Value"}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",$hdn:1,nm:"newSize"},{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",$hdn:1,nm:"growLimit"},{$t:{ta:{"Buffer.Element":{nm:"Value"}},pk:".",nm:"Buffer"},mt:"prm",$hdn:1,nm:"current"},{$t:{md:"$",ta:{"Callable.Arguments":{md:"$",pk:"$",nm:"Empty"},"Callable.Return":{md:"$",pk:"$",nm:"Anything"}},pk:"$",nm:"Callable"},mt:"prm",$hdn:1,nm:"intoNew"}]],nm:"resizeBuffer"},CharacterBuffer:{super:{ta:{"Buffer.Element":{md:"$",pk:"$",nm:"Character"}},pk:".",nm:"Buffer"},pa:1,mt:"c",an:[{doc:["Represents a buffer of [[Character]]s."]},{by:["Stéphane Épardaud","Alex Szczuczko"]}],$cn:{ofArray:{pa:1,an:[{doc:["Creates a [[CharacterBuffer]] initally backed by the given\n[[initialArray]]. The capacity of the new buffer will be the size of the\narray. The returned buffer will be ready to be `read`, with its `position`\nset to `0` and its limit set to the buffer `capacity`."]}],ps:[{$t:{md:"$",ta:{"Array.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Array"},mt:"prm",nm:"initialArray"}],nm:"ofArray"},ofSize:{pa:1,an:[{doc:["Allocates a new zeroed [[CharacterBuffer]] of the given\n[[initialCapacity]]."]}],ps:[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"initialCapacity"}],nm:"ofSize"},$def:{pa:1,an:[{doc:["Allocates a new [[CharacterBuffer]] filled with the given [[initialData]].\nThe capacity of the new buffer will be the number of bytes given. The\nreturned buffer will be ready to be `read`, with its `position` set to `0`\nand its limit set to the buffer `capacity`."]}],ps:[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"initialData"}]}},$m:{clear:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"clear"},put:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"element"}]],nm:"put"},get:{$t:{md:"$",pk:"$",nm:"Character"},pa:3,mt:"m",nm:"get"},resize:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"newSize"},{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"growLimit"}]],nm:"resize"},flip:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"flip"}},$at:{limit:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1027,$set:{mt:"s"},mt:"g",nm:"limit"},position:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1027,$set:{mt:"s"},mt:"g",nm:"position"},buf$eu2aek:{$t:{md:"$",ta:{"Array.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Array"},pa:1027,mt:"a",nm:"buf"},_position$rmo5fd:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1027,mt:"a",nm:"_position"},implementation:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Object"}]},pa:3,mt:"g",nm:"implementation"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:[{doc:["The concatenation of the [[Character]]s from [[position]] to [[limit]], by\nrepeatedly calling [[get]]."]}],nm:"string"},_limit$63ga5v:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1027,mt:"a",nm:"_limit"},capacity:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"capacity"},array:{$t:{md:"$",ta:{"Array.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Array"},pa:3,mt:"g",nm:"array"}},ps:[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"initialData"}],nm:"CharacterBuffer"},ByteBuffer:{super:{ta:{"Buffer.Element":{md:"$",pk:"$",nm:"Byte"}},pk:".",nm:"Buffer"},pa:1,mt:"c",an:[{doc:["Represents a buffer of [[Byte]]s (from 0 to 255 inclusive, unsigned)."]},{by:["Stéphane Épardaud","Alex Szczuczko"]},{native:[]}],$cn:{ofArray:{pa:1,an:[{doc:["Creates a [[ByteBuffer]] initally backed by the given [[initialArray]].\nThe capacity of the new buffer will be the size of the array. The returned\nbuffer will be ready to be `read`, with its `position` set to `0` and its\nlimit set to the buffer `capacity`."]},{native:[]}],ps:[{$t:{md:"$",ta:{"Array.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Array"},mt:"prm",nm:"initialArray"}],nm:"ofArray"},ofSize:{pa:1,an:[{doc:["Allocates a new zeroed [[ByteBuffer]] of the given [[initialCapacity]]."]},{native:[]}],ps:[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"initialCapacity"}],nm:"ofSize"},$def:{pa:1,an:[{doc:["Allocates a new [[ByteBuffer]] filled with the given [[initialData]]. The\ncapacity of the new buffer will be the number of bytes given. The returned\nbuffer will be ready to be `read`, with its `position` set to `0` and its\nlimit set to the buffer `capacity`."]},{native:[]}],ps:[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"initialData"}]}},$m:{clear:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",an:[{native:[]}],nm:"clear"},put:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",an:[{native:[]}],ps:[[{$t:{md:"$",pk:"$",nm:"Byte"},mt:"prm",nm:"element"}]],nm:"put"},get:{$t:{md:"$",pk:"$",nm:"Byte"},pa:3,mt:"m",an:[{native:[]}],nm:"get"},resize:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",an:[{native:[]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"newSize"},{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"growLimit"}]],nm:"resize"},flip:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",an:[{native:[]}],nm:"flip"}},$at:{position:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1027,mt:"a",an:[{native:[]}],nm:"position"},limit:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1027,mt:"a",an:[{native:[]}],nm:"limit"},implementation:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Object"}]},pa:3,mt:"a",an:[{native:[]}],nm:"implementation"},capacity:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{native:[]}],nm:"capacity"},array:{$t:{md:"$",ta:{"Array.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Array"},pa:3,mt:"a",an:[{native:[]}],nm:"array"}},ps:[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"initialData"}],nm:"ByteBuffer"},BufferException:{super:{md:"$",pk:"$",nm:"Exception"},pa:1,mt:"c",$at:{description$eipb31:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},mt:"a",nm:"description"},cause$tcmfeg:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},mt:"a",nm:"cause"}},ps:[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},def:1,mt:"prm",$hdn:1,nm:"description"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},def:1,mt:"prm",$hdn:1,nm:"cause"}],nm:"BufferException"},Buffer:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,mt:"c",an:[{doc:["Represents a memory buffer that can be read and written to\nwith no allocation. The easiest way to get an idea of what\na buffer is, is that it consists in an array of a given\n[[capacity]], a [[position]] index within the array, and a\n[[limit]] index.\n\nTypical operations on a buffer will be to fill it, which\nyou do with [[put]] until you reach the [[limit]].\n\nThen if you want to read the data you just put in the\nbuffer, you [[flip]] the buffer, which will set its\n[[limit]] to the current [[position]], and reset its\n[[position]] to `0`. This essentially means that you will\nbe able to read from the beginning of the buffer until the\nlast object you [[put]] in it when writing.\n\nYou can then start calling [[get]] to read objects from\nthis buffer until you reach its [[limit]].\n\nOnce you are done reading from the buffer, you can\n[[clear]] the buffer to start writing to it again. That\nwill reset the [[position]] to `0` and the [[limit]] to the\n[[capacity]], allowing you to write to the full underlying\narray.\n\nBuffers can be resized (grown and expanded), which will\ncause an underlying array reallocation and copy."]},{by:["Stéphane Épardaud"]},{see:["ByteBuffer","CharacterBuffer"]}],sts:[{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"Element"}},pk:"$",nm:"Iterable"}],tp:[{nm:"Element"}],$m:{clear:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Resets the [[position]] to `0` and the [[limit]] to the\n[[capacity]]. Use this after reading to start writing\nto a clear buffer."]}],nm:"clear"},iterator:{$t:{md:"$",ta:{"Iterator.Element":{nm:"Element"}},pk:"$",nm:"Iterator"},pa:3,mt:"m",an:[{doc:["Returns an [[Iterator]] object to read from the current\n[[position]] until the [[limit]]. This iterator modifies\nthe buffer directly, so you will need to [[clear]] or\n[[flip]] it afterwards if you wish to iterate it again."]}],$o:{it$b7396g:{super:{md:"$",pk:"$",nm:"Basic"},mt:"o",sts:[{md:"$",ta:{"Iterator.Element":{nm:"Element"}},pk:"$",nm:"Iterator"}],$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},nm:"it"}},nm:"iterator"},put:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Writes an object to this buffer at the current\n[[position]]. Increases the [[position]] by `1`."]},{throws:["BufferOverflowException","If [[position]] >= [[limit]]"]}],ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"put"},get:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Reads an object from this buffer at the current\n[[position]]. Increases the [[position]] by `1`."]},{throws:["BufferUnderflowException","If [[position]] >= [[limit]]"]}],nm:"get"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:11,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},flip:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Flips this buffer after a write operation, so that it\nis ready to be read.\n\nThis will and set its [[limit]] to the current\n[[position]], and reset its [[position]] to `0`. This\nessentially means that you will be able to read from\nthe beginning of the buffer until the last object you\n[[put]] in it when writing."]}],nm:"flip"},resize:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Resizes the underlying array, by growing or shrinking\nit. This implies a new array allocation and copy.\n\nThe [[position]] will only be affected if the\n[[newSize]] is smaller than the [[position]], in which\ncase the [[position]] will be reset down to the\n[[newSize]] (at the end of the buffer).\n\nThe [[limit]] will be brought down to the [[newSize]]\nif it would otherwise exceed it (when shrinking the\nbuffer below the old [[limit]]), effectively making the\nnew [[limit]] be at the end of the buffer.\n\nIf you are growing the array, the [[limit]] will not be\nchanged unless the optional parameter [[growLimit]] is\nset to `true` (defaults to `false`), because when you\nare writing it makes sense to grow the limit, but when\nyou are reading it usually does not, as growing a\nbuffer does not generate new meaningful data."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"newSize"},{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"growLimit"}]],nm:"resize"}},$at:{limit:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1029,mt:"a",an:[{doc:["The limit at which to stop reading and writing. The\nlimit will always be greater or equal to the\n[[position]] and smaller or equal to the [[capacity]]."]},{throws:["AssertionError","On assignment if the new value would be invalid"]}],nm:"limit"},position:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1029,mt:"a",an:[{doc:["The current position index within this buffer. Starts\nat `0` and grows with each [[get]] or [[put]] operation,\nuntil it reaches the [[limit]]."]},{throws:["AssertionError","On assignment if the new value would be invalid"]}],nm:"position"},visible:{$t:{md:"$",ta:{"List.Element":{nm:"Element"}},pk:"$",nm:"List"},pa:9,mt:"g",an:[{doc:["A sublist view of [[array]] bounded by the current values\nof [[position]] and [[limit]]. The size of the returned\nList will equal [[available]].\n\nChanges made to [[position]]\nor [[limit]] after creation of the view will not be\nsynchronized. Also, reallocations caused by a call to\n[[resize]] will cause any existing views to become stale."]}],nm:"visible"},implementation:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Object"}]},pa:5,mt:"a",an:[{doc:["The platform-specific implementation object, if any."]}],nm:"implementation"},capacity:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["The underlying array maximum capacity. Both the\n[[position]] and [[limit]] cannot exceed the capacity.\nYou can [[resize]] the array to change the [[capacity]]."]}],nm:"capacity"},hasAvailable:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,mt:"g",an:[{doc:["Returns `true` if the current [[position]] is smaller\nthan the [[limit]]."]}],nm:"hasAvailable"},available:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:[{doc:["Returns the number of objects that can be read\/written\nfrom the current\n[[position]] until we reach the [[limit]]."]}],nm:"available"},size:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"size"},array:{$t:{md:"$",ta:{"Array.Element":{nm:"Element"}},pk:"$",nm:"Array"},pa:5,mt:"a",an:[{doc:["The current underlying Array of the buffer. Any changes\nmade to the buffer will be reflected in this array, and\nvice versa.\n\nReallocations caused by a call to [[resize]] will cause any\nprior references obtained though this attribute to become\nstale."]}],nm:"array"}},nm:"Buffer"},BufferOverflowException:{super:{pk:".",nm:"BufferException"},pa:1,mt:"c",$at:{cause$8lmp7a:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},mt:"a",nm:"cause"},description$nfjtip:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},mt:"a",nm:"description"}},ps:[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},def:1,mt:"prm",$hdn:1,nm:"description"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},def:1,mt:"prm",$hdn:1,nm:"cause"}],nm:"BufferOverflowException"},"$pkg-anns":[{doc:["See [[module ceylon.buffer]]"]},{see:["module ceylon.buffer"]}],"$pkg-pa":1},"$mod-bin":"10.0","ceylon.buffer.charset":{ascii:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"o",an:[{doc:["The ASCII character set, as defined by [its specification]\n(http:\/\/tools.ietf.org\/html\/rfc20)."]},{by:["Stéphane Épardaud"]}],sts:[{pk:".",nm:"Charset"}],$m:{decodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"decodeBid"},averageDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageDecodeSize"},averageEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageEncodeSize"},maximumEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumEncodeSize"},pieceDecoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Byte"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Character"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceDecoder"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"},maximumDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumDecodeSize"},pieceEncoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Character"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Byte"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceEncoder"}},$at:{aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"ascii"},utf16:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"o",an:[{doc:["The UTF-16 character set, as defined by (its specification)\n[http:\/\/www.ietf.org\/rfc\/rfc2781.txt].\n\nDecoders for UTF-16 will properly recognize `BOM` (_byte order mark_) markers\nfor both big and little endian encodings, but encoders will generate\nbig-endian UTF-16 with no `BOM` markers."]},{by:["Stéphane Épardaud"]}],sts:[{pk:".",nm:"Charset"}],$m:{decodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"decodeBid"},averageDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageDecodeSize"},averageEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageEncodeSize"},maximumEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumEncodeSize"},pieceDecoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Byte"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Character"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceDecoder"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"},maximumDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumDecodeSize"},pieceEncoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Character"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Byte"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceEncoder"}},$at:{aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"utf16"},charsetsByAlias:{$t:{md:"$",ta:{"Map.Item":{pk:".",nm:"Charset"},"Map.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Map"},pa:1,mt:"a",an:[{doc:["A mapping of all supported character sets.\n\nCurrently this contains:\n\n- ASCII\n- ISO 8859 1\n- UTF-8\n- UTF-16\n"]}],nm:"charsetsByAlias"},Charset:{pa:1,mt:"i",an:[{doc:["A character set, which allows you to convert characters to bytes and back.\n\nYou can find a character set by a String alias with [[charsetsByAlias]]"]}],sts:[{pk:"ceylon.buffer.codec",nm:"ByteToCharacterCodec"}],nm:"Charset"},utf8:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"o",an:[{doc:["The UTF-8 character set, as defined by (its specification)\n[http:\/\/tools.ietf.org\/html\/rfc3629]."]},{by:["Stéphane Épardaud"]}],sts:[{pk:".",nm:"Charset"}],$m:{decodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"decodeBid"},averageDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageDecodeSize"},averageEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageEncodeSize"},maximumEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumEncodeSize"},pieceDecoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Byte"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Character"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceDecoder"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"},maximumDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumDecodeSize"},pieceEncoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Character"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Byte"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceEncoder"}},$at:{aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"utf8"},"$pkg-anns":[{doc:["\nThis package contains the [[Charset]] codec family. These codecs are used to\nencode Strings of text into various standardised binary representations for\nI\/O purposes.\n\nAny [[Character]] can be encoded without error by the unicode charsets\n([[utf8]] and [[utf16]]). However other charsets are only compatible with a\nlimited range of characters ([[ascii]] and [[iso_8859_1]]), and so may throw\nan [[ceylon.buffer.codec::EncodeException]]. All charsets can throw\n[[ceylon.buffer.codec::DecodeException]] when decoding [[Byte]]s into\n[[Character]]s, as the valid binary format for each is strictly defined.\n\nTo convert a [[String]] to an ASCII byte [[List]]:\n\n    List<Byte> bytes = ascii.encode(\"Hello, World!\");\n\nNow, if you want to decode it back:\n\n    String string = ascii.decode(bytes);\n    \nSimilarly, for a [[ceylon.buffer::ByteBuffer]]:\n\n    ByteBuffer bytes = utf8.encodeBuffer(\"Clear Air Turbulence\");\n    CharacterBuffer chars = utf8.decodeBuffer(bytes);\n\nIf you only know the name of a charset you can get its Charset with:\n\n    Charset? charset = charsetsByAlias[\"UTF-8\"];\n"]},{by:["Stéphane Épardaud","Alex Szczuczko"]}],"$pkg-pa":1,iso_8859_1:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"o",an:[{doc:["The ISO 8859-1 character set, as defined by [its specification]\n(http:\/\/www.iso.org\/iso\/catalogue_detail?csnumber=28245)."]},{by:["Stéphane Épardaud"]}],sts:[{pk:".",nm:"Charset"}],$m:{decodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"decodeBid"},averageDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageDecodeSize"},averageEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageEncodeSize"},maximumEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumEncodeSize"},pieceDecoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Byte"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Character"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceDecoder"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"},maximumDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumDecodeSize"},pieceEncoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Character"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Byte"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceEncoder"}},$at:{aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"iso_8859_1"}},"ceylon.buffer.base":{baseStringByAlias:{$t:{md:"$",ta:{"Map.Item":{pk:"ceylon.buffer.codec",nm:"CharacterToByteCodec"},"Map.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Map"},pa:1,mt:"a",an:[{doc:["A mapping of all supported String base variants.\n\nCurrently this contains:\n\n- Base64 Standard\n- Base64 URL Safe\n- Base16\n"]}],nm:"baseStringByAlias"},Base32String:{super:{ta:{"Base32.ToMutable":{pk:"ceylon.buffer",nm:"CharacterBuffer"},"Base32.ToImmutable":{md:"$",pk:"$",nm:"String"},"Base32.ToSingle":{md:"$",pk:"$",nm:"Character"}},pk:".",nm:"Base32"},pa:257,mt:"c",sts:[{pk:"ceylon.buffer.codec",nm:"CharacterToByteCodec"}],$at:{pad:{$t:{md:"$",pk:"$",nm:"Character"},pa:3,mt:"a",nm:"pad"}},nm:"Base32String"},base32ByteStandard:{super:{pk:".",nm:"Base32Byte"},pa:1,mt:"o",$m:{decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Byte"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"}},$at:{decodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"decodeTable"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"encodeTable"},aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"base32ByteStandard"},b64DecodeThird:{super:{pk:".",nm:"Base64PieceDecoderState"},mt:"o",nm:"b64DecodeThird"},Base64PieceDecoderState:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"b64DecodeFirst"},{pk:".",nm:"b64DecodeSecond"},{pk:".",nm:"b64DecodeThird"},{pk:".",nm:"b64DecodeFourth"}],pa:256,mt:"c",nm:"Base64PieceDecoderState"},base16Byte:{super:{pk:".",nm:"Base16Byte"},pa:1,mt:"o",$m:{encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"}},$at:{aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"base16Byte"},b32EncodeFirst:{super:{pk:".",nm:"Base32PieceEncoderState"},mt:"o",nm:"b32EncodeFirst"},hexDigits:{$t:{md:"$",ta:{"Iterable.Absent":{pk:"$",nm:"Nothing"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"a",nm:"hexDigits"},urlBase64ByteTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},mt:"a",nm:"urlBase64ByteTable"},b32DecodeEighth:{super:{pk:".",nm:"Base32PieceDecoderState"},mt:"o",nm:"b32DecodeEighth"},base64StringStandard:{super:{pk:".",nm:"Base64String"},pa:1,mt:"o",an:[{doc:["The Basic type base64 encoding scheme of [RFC 4648][rfc4648].\n[rfc4648]: http:\/\/tools.ietf.org\/html\/rfc4648"]}],$m:{decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"}},$at:{decodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"decodeTable"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"encodeTable"},aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"base64StringStandard"},b32DecodeFourth:{super:{pk:".",nm:"Base32PieceDecoderState"},mt:"o",nm:"b32DecodeFourth"},hexBase32CharTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Sequential"},mt:"a",nm:"hexBase32CharTable"},base64StringUrl:{super:{pk:".",nm:"Base64String"},pa:1,mt:"o",an:[{doc:["The URL and Filename safe type base64 encoding scheme of [RFC 4648][rfc4648].\n[rfc4648]: http:\/\/tools.ietf.org\/html\/rfc4648"]}],$m:{decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"}},$at:{decodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"decodeTable"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"encodeTable"},aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"base64StringUrl"},Base32PieceDecoderState:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"b32DecodeFirst"},{pk:".",nm:"b32DecodeSecond"},{pk:".",nm:"b32DecodeThird"},{pk:".",nm:"b32DecodeFourth"},{pk:".",nm:"b32DecodeFifth"},{pk:".",nm:"b32DecodeSixth"},{pk:".",nm:"b32DecodeSeventh"},{pk:".",nm:"b32DecodeEighth"}],pa:256,mt:"c",nm:"Base32PieceDecoderState"},b64DecodeFirst:{super:{pk:".",nm:"Base64PieceDecoderState"},mt:"o",nm:"b64DecodeFirst"},hexDigitsByte:{$t:{md:"$",ta:{"Iterable.Absent":{pk:"$",nm:"Nothing"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"a",nm:"hexDigitsByte"},b32DecodeSecond:{super:{pk:".",nm:"Base32PieceDecoderState"},mt:"o",nm:"b32DecodeSecond"},hexBase32ByteTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},mt:"a",nm:"hexBase32ByteTable"},b32DecodeSeventh:{super:{pk:".",nm:"Base32PieceDecoderState"},mt:"o",nm:"b32DecodeSeventh"},b64EncodeThird:{super:{pk:".",nm:"Base64PieceEncoderState"},mt:"o",nm:"b64EncodeThird"},b32DecodeThird:{super:{pk:".",nm:"Base32PieceDecoderState"},mt:"o",nm:"b32DecodeThird"},baseByteByAlias:{$t:{md:"$",ta:{"Map.Item":{pk:"ceylon.buffer.codec",nm:"ByteToByteCodec"},"Map.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Map"},pa:1,mt:"a",an:[{doc:["A mapping of all supported Byte base variants.\n\nCurrently this contains:\n\n- Base64 Standard\n- Base64 URL Safe\n- Base16\n"]}],nm:"baseByteByAlias"},Base32:{super:{md:"$",pk:"$",nm:"Basic"},pa:273,mt:"c",sts:[{ta:{"IncrementalCodec.ToImmutable":{nm:"ToImmutable"},"IncrementalCodec.ToMutable":{nm:"ToMutable"},"IncrementalCodec.ToSingle":{nm:"ToSingle"},"IncrementalCodec.FromSingle":{md:"$",pk:"$",nm:"Byte"},"IncrementalCodec.FromImmutable":{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},"IncrementalCodec.FromMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"}},pk:"ceylon.buffer.codec",nm:"IncrementalCodec"}],tp:[{sts:[{ta:{"Buffer.Element":{nm:"ToSingle"}},pk:"ceylon.buffer",nm:"Buffer"}],nm:"ToMutable"},{sts:[{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"}],nm:"ToImmutable"},{sts:[{md:"$",pk:"$",nm:"Object"}],nm:"ToSingle"}],$m:{decodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"decodeBid"},averageDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageDecodeSize"},decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",ps:[[{$t:{nm:"ToSingle"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"},averageEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageEncodeSize"},maximumEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumEncodeSize"},pieceDecoder:{$t:{ta:{"PieceConvert.FromSingle":{nm:"ToSingle"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Byte"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceDecoder"},maximumDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumDecodeSize"},pieceEncoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Byte"},"PieceConvert.ToSingle":{nm:"ToSingle"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceEncoder"}},$at:{pad:{$t:{nm:"ToSingle"},pa:5,mt:"a",an:[{doc:["The padding character, used where required to terminate discrete blocks of\nencoded data so they may be concatenated without making the seperation\npoint ambiguous."]}],nm:"pad"},toMutableOfSize$ok7gzq:{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},"Callable.Return":{nm:"ToMutable"}},pk:"$",nm:"Callable"},mt:"a",nm:"toMutableOfSize"},decodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:5,mt:"a",nm:"decodeTable"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{nm:"ToSingle"}},pk:"$",nm:"Sequential"},pa:5,mt:"a",nm:"encodeTable"}},ps:[{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},"Callable.Return":{nm:"ToMutable"}},pk:"$",nm:"Callable"},mt:"prm",$hdn:1,nm:"toMutableOfSize"}],nm:"Base32"},base32ByteHex:{super:{pk:".",nm:"Base32Byte"},pa:1,mt:"o",$m:{decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Byte"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"}},$at:{decodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"decodeTable"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"encodeTable"},aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"base32ByteHex"},toDecodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},mt:"m",an:[{doc:["The ASCII value of encoded Character or Byte is easily computable, so it makes\na nice common hash code. Construct a table of a size that fits the minimal\nwindow from zero to the max ASCII value of the encode table elements.\n\nIf the user provides an index that doesn't match anything in the encode table,\nthey will either get null (out of range) or 255 returned to them (in range but\nnot in the encode table).\n\nIf the given ASCII value does correspond to an element of the encode table,\nthen they will get the index of the element in the encode table. Thus, the\nencode table is efficently reversed."]}],tp:[{nm:"ToSingle"}],ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"encodeTable"},{$t:{md:"$",ta:{"Callable.Arguments":{md:"$",ta:{"Tuple.First":{nm:"ToSingle"},"Tuple.Element":{nm:"ToSingle"},"Tuple.Rest":{md:"$",pk:"$",nm:"Empty"}},pk:"$",nm:"Tuple"},"Callable.Return":{md:"$",pk:"$",nm:"Integer"}},pk:"$",nm:"Callable"},mt:"prm",nm:"decodeToIndex"},{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",pk:"$",nm:"Byte"},pk:"$",nm:"Tuple"},"Callable.Return":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Callable"},def:1,mt:"prm",nm:"fiddle"},{$t:{md:"$",ta:{"Callable.Arguments":{md:"$",ta:{"Tuple.First":{nm:"ToSingle"},"Tuple.Element":{nm:"ToSingle"},"Tuple.Rest":{md:"$",pk:"$",nm:"Empty"}},pk:"$",nm:"Tuple"},"Callable.Return":{md:"$",ta:{"Iterable.Absent":{pk:"$",nm:"Nothing"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"}},pk:"$",nm:"Callable"},def:1,mt:"prm",nm:"split"}]],nm:"toDecodeTable"},b64EncodeFirst:{super:{pk:".",nm:"Base64PieceEncoderState"},mt:"o",nm:"b64EncodeFirst"},b32DecodeSixth:{super:{pk:".",nm:"Base32PieceDecoderState"},mt:"o",nm:"b32DecodeSixth"},b32DecodeFirst:{super:{pk:".",nm:"Base32PieceDecoderState"},mt:"o",nm:"b32DecodeFirst"},Base16String:{super:{ta:{"Base16.ToMutable":{pk:"ceylon.buffer",nm:"CharacterBuffer"},"Base16.ToImmutable":{md:"$",pk:"$",nm:"String"},"Base16.ToSingle":{md:"$",pk:"$",nm:"Character"}},pk:".",nm:"Base16"},pa:257,mt:"c",sts:[{pk:"ceylon.buffer.codec",nm:"CharacterToByteCodec"}],$m:{decodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"decodeBid"},decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"}},$at:{decodeTableLeft:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"decodeTableLeft"},decodeTableRight:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"decodeTableRight"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Sequential"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"encodeTable"}},nm:"Base16String"},ceiling:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"m",an:[{doc:["ceylon.math is JVM only..."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"x"},{$t:{md:"$",pk:"$",nm:"Float"},mt:"prm",nm:"y"}]],nm:"ceiling"},b32DecodeFifth:{super:{pk:".",nm:"Base32PieceDecoderState"},mt:"o",nm:"b32DecodeFifth"},standardBase64CharTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Sequential"},mt:"a",nm:"standardBase64CharTable"},base16StringEncodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Sequential"}},pk:"$",nm:"Sequential"},mt:"a",nm:"base16StringEncodeTable"},base64ByteStandard:{super:{pk:".",nm:"Base64Byte"},pa:1,mt:"o",an:[{doc:["The Basic type base64 encoding scheme of [RFC 4648][rfc4648].\n[rfc4648]: http:\/\/tools.ietf.org\/html\/rfc4648"]}],$m:{decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Byte"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"}},$at:{decodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"decodeTable"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"encodeTable"},aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"base64ByteStandard"},b64DecodeFourth:{super:{pk:".",nm:"Base64PieceDecoderState"},mt:"o",nm:"b64DecodeFourth"},base32StringStandard:{super:{pk:".",nm:"Base32String"},pa:1,mt:"o",$m:{decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"}},$at:{decodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"decodeTable"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"encodeTable"},aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"base32StringStandard"},Base64Byte:{super:{ta:{"Base64.ToSingle":{md:"$",pk:"$",nm:"Byte"},"Base64.ToImmutable":{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},"Base64.ToMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"}},pk:".",nm:"Base64"},pa:257,mt:"c",sts:[{pk:"ceylon.buffer.codec",nm:"ByteToByteCodec"}],$at:{pad:{$t:{md:"$",pk:"$",nm:"Byte"},pa:3,mt:"a",nm:"pad"}},nm:"Base64Byte"},b32EncodeFifth:{super:{pk:".",nm:"Base32PieceEncoderState"},mt:"o",nm:"b32EncodeFifth"},standardBase64ByteTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},mt:"a",nm:"standardBase64ByteTable"},b64EncodeSecond:{super:{pk:".",nm:"Base64PieceEncoderState"},mt:"o",nm:"b64EncodeSecond"},Base64:{super:{md:"$",pk:"$",nm:"Basic"},pa:273,mt:"c",sts:[{ta:{"IncrementalCodec.ToImmutable":{nm:"ToImmutable"},"IncrementalCodec.ToMutable":{nm:"ToMutable"},"IncrementalCodec.ToSingle":{nm:"ToSingle"},"IncrementalCodec.FromSingle":{md:"$",pk:"$",nm:"Byte"},"IncrementalCodec.FromImmutable":{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},"IncrementalCodec.FromMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"}},pk:"ceylon.buffer.codec",nm:"IncrementalCodec"}],tp:[{sts:[{ta:{"Buffer.Element":{nm:"ToSingle"}},pk:"ceylon.buffer",nm:"Buffer"}],nm:"ToMutable"},{sts:[{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"}],nm:"ToImmutable"},{sts:[{md:"$",pk:"$",nm:"Object"}],nm:"ToSingle"}],$m:{decodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"decodeBid"},averageDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageDecodeSize"},decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",ps:[[{$t:{nm:"ToSingle"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"},averageEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageEncodeSize"},maximumEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumEncodeSize"},pieceDecoder:{$t:{ta:{"PieceConvert.FromSingle":{nm:"ToSingle"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Byte"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceDecoder"},maximumDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumDecodeSize"},pieceEncoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Byte"},"PieceConvert.ToSingle":{nm:"ToSingle"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceEncoder"}},$at:{pad:{$t:{nm:"ToSingle"},pa:5,mt:"a",an:[{doc:["The padding character, used where required to terminate discrete blocks of\nencoded data so they may be concatenated without making the seperation\npoint ambiguous."]}],nm:"pad"},toMutableOfSize$6vodb1:{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},"Callable.Return":{nm:"ToMutable"}},pk:"$",nm:"Callable"},mt:"a",nm:"toMutableOfSize"},decodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:5,mt:"a",nm:"decodeTable"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{nm:"ToSingle"}},pk:"$",nm:"Sequential"},pa:5,mt:"a",nm:"encodeTable"}},ps:[{$t:{md:"$",ta:{"Callable.Arguments":{count:1,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},"Callable.Return":{nm:"ToMutable"}},pk:"$",nm:"Callable"},mt:"prm",$hdn:1,nm:"toMutableOfSize"}],nm:"Base64"},Base16Byte:{super:{ta:{"Base16.ToMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"},"Base16.ToImmutable":{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},"Base16.ToSingle":{md:"$",pk:"$",nm:"Byte"}},pk:".",nm:"Base16"},pa:257,mt:"c",sts:[{pk:"ceylon.buffer.codec",nm:"ByteToByteCodec"}],$m:{decodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"decodeBid"},decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Byte"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"}},$at:{decodeTableLeft:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"decodeTableLeft"},decodeTableRight:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"decodeTableRight"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"encodeTable"}},nm:"Base16Byte"},standardBase32ByteTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},mt:"a",nm:"standardBase32ByteTable"},Base64PieceEncoderState:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"b64EncodeFirst"},{pk:".",nm:"b64EncodeSecond"},{pk:".",nm:"b64EncodeThird"}],pa:256,mt:"c",nm:"Base64PieceEncoderState"},b64DecodeSecond:{super:{pk:".",nm:"Base64PieceDecoderState"},mt:"o",nm:"b64DecodeSecond"},urlBase64CharTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Sequential"},mt:"a",nm:"urlBase64CharTable"},"$pkg-pa":1,b32EncodeFourth:{super:{pk:".",nm:"Base32PieceEncoderState"},mt:"o",nm:"b32EncodeFourth"},b32EncodeSecond:{super:{pk:".",nm:"Base32PieceEncoderState"},mt:"o",nm:"b32EncodeSecond"},b32EncodeThird:{super:{pk:".",nm:"Base32PieceEncoderState"},mt:"o",nm:"b32EncodeThird"},Base32Byte:{super:{ta:{"Base32.ToMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"},"Base32.ToImmutable":{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},"Base32.ToSingle":{md:"$",pk:"$",nm:"Byte"}},pk:".",nm:"Base32"},pa:257,mt:"c",sts:[{pk:"ceylon.buffer.codec",nm:"ByteToByteCodec"}],$at:{pad:{$t:{md:"$",pk:"$",nm:"Byte"},pa:3,mt:"a",nm:"pad"}},nm:"Base32Byte"},Base64String:{super:{ta:{"Base64.ToSingle":{md:"$",pk:"$",nm:"Character"},"Base64.ToImmutable":{md:"$",pk:"$",nm:"String"},"Base64.ToMutable":{pk:"ceylon.buffer",nm:"CharacterBuffer"}},pk:".",nm:"Base64"},pa:257,mt:"c",sts:[{pk:"ceylon.buffer.codec",nm:"CharacterToByteCodec"}],$at:{pad:{$t:{md:"$",pk:"$",nm:"Character"},pa:3,mt:"a",nm:"pad"}},nm:"Base64String"},Base16:{super:{md:"$",pk:"$",nm:"Basic"},pa:273,mt:"c",sts:[{ta:{"IncrementalCodec.ToImmutable":{nm:"ToImmutable"},"IncrementalCodec.ToMutable":{nm:"ToMutable"},"IncrementalCodec.ToSingle":{nm:"ToSingle"},"IncrementalCodec.FromSingle":{md:"$",pk:"$",nm:"Byte"},"IncrementalCodec.FromImmutable":{md:"$",ta:{"List.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"List"},"IncrementalCodec.FromMutable":{pk:"ceylon.buffer",nm:"ByteBuffer"}},pk:"ceylon.buffer.codec",nm:"IncrementalCodec"}],tp:[{sts:[{ta:{"Buffer.Element":{nm:"ToSingle"}},pk:"ceylon.buffer",nm:"Buffer"}],nm:"ToMutable"},{sts:[{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"ToSingle"}},pk:"$",nm:"Iterable"}],nm:"ToImmutable"},{sts:[{md:"$",pk:"$",nm:"Object"}],nm:"ToSingle"}],$m:{decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",ps:[[{$t:{nm:"ToSingle"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"},averageDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageDecodeSize"},averageEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageEncodeSize"},maximumEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumEncodeSize"},pieceDecoder:{$t:{ta:{"PieceConvert.FromSingle":{nm:"ToSingle"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Byte"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceDecoder"},maximumDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumDecodeSize"},pieceEncoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Byte"},"PieceConvert.ToSingle":{nm:"ToSingle"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceEncoder"}},$at:{decodeTableLeft:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:5,mt:"a",an:[{doc:["The decode table with a precomputed bitwise shift"]}],nm:"decodeTableLeft"},decodeTableRight:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:5,mt:"a",an:[{doc:["The plain decode table"]}],nm:"decodeTableRight"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",ta:{"Sequential.Element":{nm:"ToSingle"}},pk:"$",nm:"Sequential"}},pk:"$",nm:"Sequential"},pa:5,mt:"a",nm:"encodeTable"}},nm:"Base16"},base16ByteEncodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"}},pk:"$",nm:"Sequential"},mt:"a",nm:"base16ByteEncodeTable"},base16String:{super:{pk:".",nm:"Base16String"},pa:1,mt:"o",$m:{encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"}},$at:{aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"base16String"},standardBase32CharTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Sequential"},mt:"a",nm:"standardBase32CharTable"},Base32PieceEncoderState:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"b32EncodeFirst"},{pk:".",nm:"b32EncodeSecond"},{pk:".",nm:"b32EncodeThird"},{pk:".",nm:"b32EncodeFourth"},{pk:".",nm:"b32EncodeFifth"}],pa:256,mt:"c",nm:"Base32PieceEncoderState"},base64ByteUrl:{super:{pk:".",nm:"Base64Byte"},pa:1,mt:"o",an:[{doc:["The URL and Filename safe type base64 encoding scheme of [RFC 4648][rfc4648].\n[rfc4648]: http:\/\/tools.ietf.org\/html\/rfc4648"]}],$m:{decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Byte"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"}},$at:{decodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"decodeTable"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"encodeTable"},aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"base64ByteUrl"},base32StringHex:{super:{pk:".",nm:"Base32String"},pa:1,mt:"o",$m:{decodeToIndex:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"input"}]],nm:"decodeToIndex"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"}},$at:{decodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Byte"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"decodeTable"},encodeTable:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Sequential"},pa:3,mt:"a",nm:"encodeTable"},aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:3,mt:"a",nm:"aliases"}},nm:"base32StringHex"},"$pkg-anns":[{doc:["\nThis package contains the \"base\" codecs defined by [RFC 4648][rfc4648].\nThese codecs are used to encode binary data into various standardised text\nrepresentations for portability in environments that are not binary-safe.\n\nSince the text output of each of the primary\n[[ceylon.buffer.codec::CharacterToByteCodec]] codecs (labelled `String`) in\nthis family are within the range of ASCII characters, they all have a\nvariant [[ceylon.buffer.codec::ByteToByteCodec]] codec (labelled `Byte`)\nthat outputs the [[ceylon.buffer.charset::ascii]] encoded characters\ndirectly. This is sometimes desireable for efficiency reasons.\n\nAny [[Byte]] can be encoded without error by all of the codecs in this\nfamily. However [[ceylon.buffer.codec::DecodeException]] may be thrown when\ndecoding [[Character]]s or [[Byte]]s into [[Byte]]s, as the valid text\nformat for each codec is strictly defined.\n\nSome of the codecs' text forms append padding characters (typically `=`) to\nprevent ambiguity when concatenated. If you're transporting them discretely\nit is technically safe to remove these padding characters. However, while\nthe decode functions of the codecs implemented here accept padding-less\ninput, it's not uncommon for other libraries to only accept properly padded\ninput. Portability may be affected by removing the padding characters.\n\nTo convert some [[Byte]]s into a base64 String:\n\n    String string = base64StringStandard.encode({0, 1, 2}*.byte);\n\nNow, if you want to decode it back:\n\n    List<Byte> bytes = base64StringStandard.decode(string);\n    \nSimilarly, for a [[ceylon.buffer::Buffer]]:\n\n    CharacterBuffer chars = base64StringUrl.encodeBuffer({3, 2, 1}*.byte);\n    ByteBuffer bytes = base64StringUrl.decodeBuffer(chars);\n\nIf you only know the name of a `base` you can get its `String` form with\n\n    CharacterToByteCodec? codec = baseStringByAlias[\"base32hex\"];\n\nand its `Byte` form with\n\n    ByteToByteCodec? codec = baseByteByAlias[\"base32hex\"];\n\n[rfc4648]: http:\/\/tools.ietf.org\/html\/rfc4648"]},{by:["Stéphane Épardaud","Alex Szczuczko"]}]},"ceylon.buffer.text":{Substitution:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["A classic simple substitution cipher.\n\nAny character found to be a key in the [[encodeMapping]]\/[[decodeMapping]] is\nreplaced with its corresponding item. Other characters are passed through\nwithout modification."]}],sts:[{pk:"ceylon.buffer.codec",nm:"CharacterToCharacterCodec"}],$m:{decodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"decodeBid"},averageDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageDecodeSize"},averageEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"averageEncodeSize"},maximumEncodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumEncodeSize"},pieceDecoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Character"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Character"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceDecoder"},encodeBid:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"sample"}]],nm:"encodeBid"},maximumDecodeSize:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"inputSize"}]],nm:"maximumDecodeSize"},pieceEncoder:{$t:{ta:{"PieceConvert.FromSingle":{md:"$",pk:"$",nm:"Character"},"PieceConvert.ToSingle":{md:"$",pk:"$",nm:"Character"}},pk:"ceylon.buffer.codec",nm:"PieceConvert"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.buffer.codec",nm:"ErrorStrategy"},def:1,mt:"prm",nm:"error"}]],nm:"pieceEncoder"}},$at:{encodeMapping:{$t:{md:"$",ta:{"Map.Item":{md:"$",pk:"$",nm:"Character"},"Map.Key":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Map"},pa:1,mt:"a",nm:"encodeMapping"},decodeMapping:{$t:{md:"$",ta:{"Map.Item":{md:"$",pk:"$",nm:"Character"},"Map.Key":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Map"},pa:1,mt:"a",nm:"decodeMapping"},aliases:{$t:{md:"$",ta:{"Sequence.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequence"},pa:11,mt:"a",nm:"aliases"}},ps:[{$t:{md:"$",ta:{"Map.Item":{md:"$",pk:"$",nm:"Character"},"Map.Key":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Map"},pa:1,mt:"prm",$hdn:1,nm:"encodeMapping"}],nm:"Substitution"},rot13:{super:{pk:".",nm:"Substitution"},pa:1,mt:"o",an:[{doc:["A common case of the Caesar cipher, using a key of 13."]}],nm:"rot13"},"$pkg-anns":[{doc:["This package contains implementations of\n[[ceylon.buffer.codec::CharacterToCharacterCodec]]s"]}],"$pkg-pa":1,caesarMapping:{$t:{md:"$",ta:{"Map.Item":{md:"$",pk:"$",nm:"Character"},"Map.Key":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Map"},pa:1,mt:"m",an:[{doc:["Creates an encode mapping for [[Substitution]] that performs a Caesar cipher.\nThis replaces each of the 26 characters of the basic latin alphabet with\nanother of those characters, [[key]] places away from the original.\n\nBoth uppercase and lowercase letters are affected."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",an:[{doc:["The maxiumum offset is 25\/-25, values of greater mangnitude than this are\ntreated modulo 26."]}],$hdn:1,nm:"key"}]],nm:"caesarMapping"}}};
});
}(typeof define==='function' && define.amd ? define : function (factory) {
if (typeof exports!=='undefined') { factory(require, exports, module);
} else { throw 'no module loader'; }
}));
