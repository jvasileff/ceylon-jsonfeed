(function(define) { define(function(require, ex$, module) {
ex$.$CCMM$={"$mod-deps":["ceylon.language\/1.3.2",{path:"ceylon.collection\/1.3.2",exp:1}],"$mod-name":"ceylon.json","$mod-version":"1.3.2","$mod-anns":[{doc:["Contains everything required to parse and serialise JSON \ndata.\n\nSample usage for parsing and accessing JSON:\n\n    import ceylon.json {\n        parse, Object = Object\n    }\n\n    String getAuthor(String json){\n        value parsedJson = parse(json);\n        \"author must be a string\"\n        assert(is Object parsedJson, is String author = parsedJson[\"author\"]);\n        return author;\n    }\n\nAlternatively, this variation will result in an \n[[InvalidTypeException]] instead of an [[AssertionError]]\nif the input JSON data doesn't have the expected format:\n\n    import ceylon.json {\n        parse, Object\n    }\n\n    String getAuthor(String json){\n        assert(is Object parsedJson = parse(json));\n        return parsedJson.getString(\"author\");\n    }\n\nYou can iterate JSON objects too:\n\n    import ceylon.json {\n        parse, Array, Object\n    }\n\n    {String*} getModules(String json){\n        assert(is Object parsedJson = parse(json));\n        if(is Array modules = parsedJson.get(\"modules\")){\n            return { for (mod in modules) \n                       if(is Object mod, \n                          is String name = mod.get(\"name\")) \n                         name \n                   };\n        }\n        throw Exception(\"Invalid JSON data\");\n    }\n\nSample usage for generating JSON data:\n\n    import ceylon.json {\n        Object, Array\n    }\n\n    String getJSON(){\n        value json = Object {\n            \"name\" -> \"Introduction to Ceylon\",\n            \"authors\" -> Array {\n                \"Stef Epardaud\",\n                \"Emmanuel Bernard\"\n            }\n        };\n        return json.string;\n    }\n"]},{by:["Stéphane Épardaud","Tom Bentley"]},{license:["Apache Software License"]}],"$mod-bin":"10.0","ceylon.json":{parseKeyOrString:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"m",an:[{doc:["Parse a String literal, consuming any initial whitespace"]}],ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],nm:"parseKeyOrString"},StringParser:{super:{pk:".",nm:"Parser"},pa:1,mt:"c",an:[{doc:["A parser for JSON data presented as a String which calls  \nthe given visitor for each matched rule. \n\nTo construct a JSON model the visitor would be a [[Builder]]."]},{by:["Stéphane Épardaud"]}],$at:{visitor$qsoxsm:{$t:{pk:".",nm:"Visitor"},mt:"a",nm:"visitor"},str$puzo67:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",an:[{doc:["The string of JSON data to be parsed."]}],nm:"str"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",an:[{doc:["The string of JSON data to be parsed."]}],nm:"str"},{$t:{pk:".",nm:"Visitor"},mt:"prm",nm:"visitor"}],nm:"StringParser"},Parser:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["A parser for JSON data presented as a Tokenizer which calls  \nthe given visitor for each matched rule. \n\nTo construct a JSON model the visitor would be a [[Builder]]."]},{by:["Stéphane Épardaud"]}],$m:{parseArray$qjniqd:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",nm:"parseArray"},parseString$sljd25:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",nm:"parseString"},parseObject$jwd68v:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",nm:"parseObject"},parse:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:1,mt:"m",nm:"parse"},parseValue:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:1,mt:"m",an:[{throws:["ParseException","If the specified string cannot be parsed"]}],nm:"parseValue"}},$at:{tokenizer$6turdq:{$t:{pk:".",nm:"Tokenizer"},mt:"a",an:[{doc:["The data to be parsed."]}],nm:"tokenizer"},visitor:{$t:{pk:".",nm:"Visitor"},pa:1,mt:"a",an:[{doc:["The visitor to called for each matched rule."]}],nm:"visitor"}},ps:[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",an:[{doc:["The data to be parsed."]}],$hdn:1,nm:"tokenizer"},{$t:{pk:".",nm:"Visitor"},pa:1,mt:"prm",an:[{doc:["The visitor to called for each matched rule."]}],$hdn:1,nm:"visitor"}],nm:"Parser"},formatNumber:{$t:{md:"$",pk:"$",nm:"String"},mt:"m",an:[{doc:["Formats a `Number`, handling infinity and undefined Floats."]}],ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"}]},mt:"prm",nm:"n"}]],nm:"formatNumber"},JsonArray:{super:{pk:".",nm:"Array"},pa:1,mt:"c",an:[{doc:["Alternative name for [[Array]] which avoids collision with\nceylon.language::Array."]}],$alias:1,ps:[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{pk:".",nm:"Value"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"values"}],nm:"JsonArray"},Array:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["Represents a JSON Array"]},{by:["Stéphane Épardaud"]}],sts:[{md:"ceylon.collection",ta:{"MutableList.Element":{pk:".",nm:"Value"}},pk:"ceylon.collection",nm:"MutableList"}],$m:{measure:{$t:{pk:".",nm:"Array"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"from"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},remove:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"ObjectValue"},mt:"prm",nm:"val"}]],nm:"remove"},set:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],nm:"set"},deleteSpan:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"from"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"deleteSpan"},deleteMeasure:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"from"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"deleteMeasure"},findAndReplaceLast:{$t:{pk:".",nm:"Value"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{pk:".",nm:"Value"},{md:"$",pk:"$",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"replacement"}]],nm:"findAndReplaceLast"},add:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",an:[{doc:["Adds a new value at the end of this array"]}],ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],nm:"add"},clear:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"clear"},removeWhere:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{pk:".",nm:"Value"},{md:"$",pk:"$",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"removeWhere"},findAndReplaceFirst:{$t:{pk:".",nm:"Value"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{pk:".",nm:"Value"},{md:"$",pk:"$",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"replacement"}]],nm:"findAndReplaceFirst"},checkArray$61ubg2:{$t:{pk:".",nm:"Array"},mt:"m",an:[{throws:["InvalidTypeException"]}],ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],nm:"checkArray"},spanTo:{$t:{pk:".",nm:"Array"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},delete:{$t:{pk:".",nm:"Value"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"delete"},insertAll:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"index"},{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{pk:".",nm:"Value"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"elements"}]],nm:"insertAll"},replaceFirst:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"ObjectValue"},mt:"prm",nm:"element"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"replacement"}]],nm:"replaceFirst"},findAndRemoveLast:{$t:{pk:".",nm:"Value"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{pk:".",nm:"Value"},{md:"$",pk:"$",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"findAndRemoveLast"},spanFrom:{$t:{pk:".",nm:"Array"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},removeFirst:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"ObjectValue"},mt:"prm",nm:"element"}]],nm:"removeFirst"},removeAll:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{pk:".",nm:"ObjectValue"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"elements"}]],nm:"removeAll"},clone:{$t:{pk:".",nm:"Array"},pa:3,mt:"m",nm:"clone"},iterator:{$t:{md:"$",ta:{"Iterator.Element":{pk:".",nm:"Value"}},pk:"$",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},checkObject$ioowmw:{$t:{pk:".",nm:"Object"},mt:"m",an:[{throws:["InvalidTypeException"]}],ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],nm:"checkObject"},addAll:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{pk:".",nm:"Value"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"values"}]],nm:"addAll"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},removeLast:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"ObjectValue"},mt:"prm",nm:"element"}]],nm:"removeLast"},prune:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",nm:"prune"},checkBoolean$v3xsa1:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"m",an:[{throws:["InvalidTypeException"]}],ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],nm:"checkBoolean"},infill:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"replacement"}]],nm:"infill"},checkInteger$4waw35:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"m",an:[{throws:["InvalidTypeException"]}],ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],nm:"checkInteger"},getFromFirst:{$t:{pk:".",nm:"Value"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},replace:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"ObjectValue"},mt:"prm",nm:"val"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"newVal"}]],nm:"replace"},replaceLast:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"ObjectValue"},mt:"prm",nm:"element"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"replacement"}]],nm:"replaceLast"},truncate:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"size"}]],nm:"truncate"},checkFloat$zgce4d:{$t:{md:"$",pk:"$",nm:"Float"},mt:"m",an:[{throws:["InvalidTypeException"]}],ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],nm:"checkFloat"},replaceWhere:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{pk:".",nm:"Value"},{md:"$",pk:"$",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"replacement"}]],nm:"replaceWhere"},findAndRemoveFirst:{$t:{pk:".",nm:"Value"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{pk:".",nm:"Value"},{md:"$",pk:"$",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"findAndRemoveFirst"},checkString$9ziptm:{$t:{md:"$",pk:"$",nm:"String"},mt:"m",an:[{throws:["InvalidTypeException"]}],ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],nm:"checkString"},insert:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],nm:"insert"},span:{$t:{pk:".",nm:"Array"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"from"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"}},$at:{integers:{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Integer"}},pk:"$",nm:"Iterable"},pa:1,mt:"g",an:[{doc:["Returns this array as a sequence of [[Integer]] elements."]},{throws:["InvalidTypeException","If one element in this array is not a [[Integer]]."]}],nm:"integers"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"hash"},strings:{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Iterable"},pa:1,mt:"g",an:[{doc:["Returns this array as a sequence of [[String]] elements."]},{throws:["InvalidTypeException","If one element in this array is not a [[String]]."]}],nm:"strings"},booleans:{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Boolean"}},pk:"$",nm:"Iterable"},pa:1,mt:"g",an:[{doc:["Returns this array as a sequence of [[Boolean]] elements."]},{throws:["InvalidTypeException","If one element in this array is not a [[Boolean]]."]}],nm:"booleans"},floats:{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",pk:"$",nm:"Float"}},pk:"$",nm:"Iterable"},pa:1,mt:"g",an:[{doc:["Returns this array as a sequence of [[Float]] elements."]},{throws:["InvalidTypeException","If one element in this array is not a [[Float]]."]}],nm:"floats"},pretty:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"g",an:[{doc:["Returns a pretty-printed serialised JSON representation"]}],nm:"pretty"},size:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns the number of elements in this array"]}],nm:"size"},lastIndex:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"},values$vcoj45:{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{pk:".",nm:"Value"}},pk:"$",nm:"Iterable"},mt:"a",nm:"values"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:[{doc:["Returns a serialised JSON representation"]}],nm:"string"},list$eh7yhj:{$t:{md:"ceylon.collection",ta:{"LinkedList.Element":{pk:".",nm:"Value"}},pk:"ceylon.collection",nm:"LinkedList"},mt:"a",nm:"list"},reversed:{$t:{pk:".",nm:"Array"},pa:3,mt:"g",nm:"reversed"},rest:{$t:{pk:".",nm:"Array"},pa:3,mt:"g",nm:"rest"},objects:{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{pk:".",nm:"Object"}},pk:"$",nm:"Iterable"},pa:1,mt:"g",an:[{doc:["Returns this array as a sequence of [[Object]] elements."]},{throws:["InvalidTypeException","If one element in this array is not an [[Object]]."]}],nm:"objects"},arrays:{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{pk:".",nm:"Array"}},pk:"$",nm:"Iterable"},pa:1,mt:"g",an:[{doc:["Returns this array as a sequence of [[Array]] elements."]},{throws:["InvalidTypeException","If one element in this array is not an [[Array]]."]}],nm:"arrays"}},ps:[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{pk:".",nm:"Value"}},pk:"$",nm:"Iterable"},def:1,mt:"prm",nm:"values"}],nm:"Array"},visit:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:1,mt:"m",an:[{doc:["Recursively visit the given subject using the given visitor. If \n[[sortedKeys]] is true then the keys of Objects will be visited \nin alphabetical order"]},{by:["Tom Bentley"]}],ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",an:[{doc:["The value to visit."]}],$hdn:1,nm:"subject"},{$t:{pk:".",nm:"Visitor"},mt:"prm",an:[{doc:["The visitor to apply."]}],$hdn:1,nm:"visitor"},{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",an:[{doc:["Whether keys should be visited in alphabetical order, when visiting objects."]}],$hdn:1,nm:"sortedKeys"}]],nm:"visit"},Positioned:{pa:1,mt:"i",an:[{doc:["Contract for stateful iterators, tokenizers etc which have the concept of a 'current position'."]}],$at:{position:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["The position (in characters) within the input."]}],nm:"position"},location:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"g",an:[{doc:["A string descriptor of the current position."]}],nm:"location"},column:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["The column number within the current line."]}],nm:"column"},line:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["The line number within the input."]}],nm:"line"}},nm:"Positioned"},ParseException:{super:{md:"$",pk:"$",nm:"Exception"},pa:1,mt:"c",an:[{doc:["An Exception throw during parse errors"]}],$at:{column:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["The error column (1-based)"]}],nm:"column"},line:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["The error line (1-based)"]}],nm:"line"},message$55bchf:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"message"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"message"},{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"prm",an:[{doc:["The error line (1-based)"]}],nm:"line"},{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"prm",an:[{doc:["The error column (1-based)"]}],nm:"column"}],nm:"ParseException"},compareKeys:{$t:{md:"$",pk:"$",nm:"Comparison"},mt:"m",ps:[[{$t:{md:"$",ta:{"Entry.Item":{pk:".",nm:"Value"},"Entry.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Entry"},mt:"prm",nm:"x"},{$t:{md:"$",ta:{"Entry.Item":{pk:".",nm:"Value"},"Entry.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Entry"},mt:"prm",nm:"y"}]],nm:"compareKeys"},StringEmitter:{super:{pk:".",nm:"Emitter"},pa:1,mt:"c",an:[{doc:["A JSON Emitter that prints to a [[String]]."]},{by:["Tom Bentley"]}],$m:{print:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",an:[{doc:["Appends the given value to our `String` representation"]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"print"}},$at:{pretty$c2sib1:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"a",nm:"pretty"},builder$b3xuq8:{$t:{md:"$",pk:"$",nm:"StringBuilder"},mt:"a",nm:"builder"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:11,mt:"g",an:[{doc:["Returns the printed JSON"]}],nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"pretty"}],nm:"StringEmitter"},ObjectValue:{pa:1,mt:"als",an:[{doc:["A JSON value, a [[String]], [[Boolean]], [[Integer]],\n[[Float]], JSON [[Object]], or JSON [[Array]].\n\nThis means [[Value]] except [[Null]]."]}],$alias:{comp:"u",l:[{md:"$",pk:"$",nm:"String"},{md:"$",pk:"$",nm:"Boolean"},{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"},{pk:".",nm:"Object"},{pk:".",nm:"Array"}]},nm:"ObjectValue"},Visitor:{pa:1,mt:"i",an:[{doc:["Callable interface used when traversing JSON data. \n\nIt is the callers responsiblity to ensure the \nmethods of this interface are called in a sequence \nthat corresponds to well-formed JSON. \nFor example, callers should never generate the calling\nsequence `onKey()`, `onKey()`."]},{by:["Tom Bentley"]}],$m:{onBoolean:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Called when encountering true or false."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",nm:"boolean"}]],nm:"onBoolean"},onKey:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Called when encountering a key within a the current object."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"onKey"},onStartObject:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Called at the start of a new object.\nFurther calls pertain to this new object until \na corresponding call to [[onEndObject]]."]}],nm:"onStartObject"},onEndArray:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Called at the end of an array."]}],nm:"onEndArray"},onStartArray:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Called at the start of a new array. \nFurther calls pertain to this new object until \na corresponding call to [[onEndArray]]."]}],nm:"onStartArray"},onNumber:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Called when encountering a number."]}],ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"}]},mt:"prm",nm:"number"}]],nm:"onNumber"},onString:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Called when encountering a string."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"onString"},onNull:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Called when encountering a null."]}],nm:"onNull"},onEndObject:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Called at the end of an object."]}],nm:"onEndObject"}},nm:"Visitor"},parseHex:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"m",ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],nm:"parseHex"},parseExponent:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},mt:"m",ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],nm:"parseExponent"},Builder:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["A [[Visitor]] that constructs a [[Value]].\n\nThis would usually be used in conjunction with \na [[StringParser]]."]},{by:["Tom Bentley"]}],sts:[{pk:".",nm:"Visitor"}],$m:{onBoolean:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",nm:"bool"}]],nm:"onBoolean"},onKey:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"onKey"},onStartObject:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"onStartObject"},onEndArray:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"onEndArray"},onStartArray:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"onStartArray"},push$ml0ud7:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"v"}]],nm:"push"},pop$r7gvbw:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",nm:"pop"},addToCurrent$lxw5io:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"v"}]],nm:"addToCurrent"},onNumber:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"}]},mt:"prm",nm:"num"}]],nm:"onNumber"},onString:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"onString"},onNull:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"onNull"},onEndObject:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"onEndObject"}},$at:{result:{$t:{pk:".",nm:"Value"},pa:1,mt:"g",an:[{doc:["The constructed [[Value]]."]},{throws:["AssertionError","The builder has not yet seen enough input to return a fully formed JSON value."]}],nm:"result"},stack$utn8fx:{$t:{md:"ceylon.collection",ta:{"ArrayList.Element":{pk:".",nm:"Value"}},pk:"ceylon.collection",nm:"ArrayList"},mt:"a",nm:"stack"},currentKey$xesi29:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},pa:1027,mt:"a",nm:"currentKey"}},nm:"Builder"},parseNull:{$t:{md:"$",pk:"$",nm:"Null"},pa:1,mt:"m",an:[{doc:["Parse null, consuming any initial whitespace"]}],ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],nm:"parseNull"},parseFalse:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,mt:"m",an:[{doc:["Parse false, consuming any initial whitespace"]}],ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],nm:"parseFalse"},parse:{$t:{pk:".",nm:"Value"},pa:1,mt:"m",an:[{doc:["Parses a JSON string into a JSON value"]},{by:["Stéphane Épardaud"]},{throws:["Exception","If the JSON string is invalid"]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"str"}]],nm:"parse"},parseStringEscape:{$t:{md:"$",pk:"$",nm:"Character"},mt:"m",ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],nm:"parseStringEscape"},"$pkg-pa":1,Object:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["Represents a JSON Object"]},{by:["Stéphane Épardaud"]}],sts:[{md:"ceylon.collection",ta:{"MutableMap.Key":{md:"$",pk:"$",nm:"String"},"MutableMap.Item":{pk:".",nm:"Value"}},pk:"ceylon.collection",nm:"MutableMap"}],$m:{clone:{$t:{pk:".",nm:"Object"},pa:3,mt:"m",nm:"clone"},iterator:{$t:{md:"$",ta:{"Iterator.Element":{md:"$",ta:{"Entry.Item":{pk:".",nm:"Value"},"Entry.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Entry"}},pk:"$",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},put:{$t:{pk:".",nm:"Value"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"item"}]],nm:"put"},get:{$t:{pk:".",nm:"Value"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"key"}]],nm:"get"},remove:{$t:{pk:".",nm:"Value"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"remove"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},getBoolean:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,mt:"m",an:[{doc:["Returns an [[Boolean]] value."]},{throws:["InvalidTypeException","If the key dot not exist or points to a type that \nis not [[Boolean]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"getBoolean"},getObjectOrNull:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Object"}]},pa:1,mt:"m",an:[{doc:["Returns an [[Object]] value, unless the key does not \nexist, or the value is null."]},{throws:["InvalidTypeException","If the key points to a type that is neither \n[[Object]] nor [[Null]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"getObjectOrNull"},getFloatOrNull:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Float"}]},pa:1,mt:"m",an:[{doc:["Returns an [[Float]] value, unless the key does not \nexist, or the value is null."]},{throws:["InvalidTypeException","If the key points to a type that is neither \n[[Float]] nor [[Null]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"getFloatOrNull"},getArray:{$t:{pk:".",nm:"Array"},pa:1,mt:"m",an:[{doc:["Returns an [[Array]] value."]},{throws:["InvalidTypeException","If the key dot not exist or points to a type that \nis not [[Array]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"getArray"},clear:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"clear"},getArrayOrNull:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Array"}]},pa:1,mt:"m",an:[{doc:["Returns an [[Array]] value, unless the key does not \nexist, or the value is null."]},{throws:["InvalidTypeException","If the key points to a type that is neither \n[[Array]] nor [[Null]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"getArrayOrNull"},defines:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"key"}]],nm:"defines"},getIntegerOrNull:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},pa:1,mt:"m",an:[{doc:["Returns an [[Integer]] value, unless the key does not \nexist, or the value is null."]},{throws:["InvalidTypeException","If the key points to a type that is neither \n[[Integer]] nor [[Null]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"getIntegerOrNull"},getInteger:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns an [[Integer]] value."]},{throws:["InvalidTypeException","If the key dot not exist or points to a type that \nis not [[Integer]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"getInteger"},getStringOrNull:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},pa:1,mt:"m",an:[{doc:["Returns an [[String]] value, unless the key does not \nexist, or the value is null."]},{throws:["InvalidTypeException","If the key points to a type that is neither \n[[String]] nor [[Null]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"getStringOrNull"},putAll:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",ta:{"Entry.Item":{pk:".",nm:"Value"},"Entry.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Entry"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"entries"}]],nm:"putAll"},getString:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"m",an:[{doc:["Returns an [[String]] value."]},{throws:["InvalidTypeException","If the key dot not exist or points to a type that \nis not [[String]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"getString"},getFloat:{$t:{md:"$",pk:"$",nm:"Float"},pa:1,mt:"m",an:[{doc:["Returns an [[Float]] value."]},{throws:["InvalidTypeException","If the key dot not exist or points to a type that \nis not [[Float]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"getFloat"},getBooleanOrNull:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Boolean"}]},pa:1,mt:"m",an:[{doc:["Returns an [[Boolean]] value, unless the key does not \nexist, or the value is null."]},{throws:["InvalidTypeException","If the key points to a type that is neither \n[[Boolean]] nor [[Null]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"getBooleanOrNull"},getObject:{$t:{pk:".",nm:"Object"},pa:1,mt:"m",an:[{doc:["Returns an [[Object]] value."]},{throws:["InvalidTypeException","If the key dot not exist or points to a type that \nis not [[Object]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"getObject"}},$at:{contents$adyvg7:{$t:{md:"ceylon.collection",ta:{"HashMap.Item":{pk:".",nm:"Value"},"HashMap.Key":{md:"$",pk:"$",nm:"String"}},pk:"ceylon.collection",nm:"HashMap"},mt:"a",nm:"contents"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"hash"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:[{doc:["Returns a serialised JSON representation"]}],nm:"string"},pretty:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"g",an:[{doc:["Returns a pretty-printed serialised JSON representation"]}],nm:"pretty"},size:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"size"},values$6zuosx:{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",ta:{"Entry.Item":{pk:".",nm:"Value"},"Entry.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Entry"}},pk:"$",nm:"Iterable"},mt:"a",nm:"values"}},ps:[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",ta:{"Entry.Item":{pk:".",nm:"Value"},"Entry.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Entry"}},pk:"$",nm:"Iterable"},def:1,mt:"prm",nm:"values"}],nm:"Object"},Tokenizer:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,mt:"c",an:[{doc:["Contract for a tokenizer"]}],sts:[{pk:".",nm:"Positioned"}],$m:{check:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,mt:"m",an:[{doc:["If the current [[character]] is not the given character then return false. \nOtherwise [[moveOne]] and return true."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"c"}]],nm:"check"},eatChar:{$t:{md:"$",pk:"$",nm:"Character"},pa:1,mt:"m",an:[{doc:["The character at the current index, and move one"]}],nm:"eatChar"},exception:{$t:{pk:".",nm:"ParseException"},pa:1,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"message"}]],nm:"exception"},eat:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:1,mt:"m",an:[{doc:["If the current character is not the given character then throw, \notherwise [[moveOne]]"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"c"}]],nm:"eat"},isDigit:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,mt:"m",an:[{doc:["true if the given character is \n`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8` or `9`."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"c"}]],nm:"isDigit"},isSpace:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,mt:"m",an:[{doc:["true if the given character is a space, \nnewline (`\\n`), carriage return (`\\r`) or a horizontal tab (`\\t`).\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"c"}]],nm:"isSpace"},eatSpacesUntil:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:1,mt:"m",an:[{doc:["Consume characters until the given character occurs"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"c"}]],nm:"eatSpacesUntil"},moveOne:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:1,mt:"m",an:[{doc:["Move to the next character"]}],nm:"moveOne"},unexpectedCharacter:{$t:{pk:".",nm:"ParseException"},pa:1,mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Character"},{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]}]},mt:"prm",nm:"expected"}]],nm:"unexpectedCharacter"},eatSpaces:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:1,mt:"m",an:[{doc:["Consume characters until the first non-whitespace"]}],nm:"eatSpaces"},character:{$t:{md:"$",pk:"$",nm:"Character"},pa:5,mt:"m",an:[{doc:["The character at the current index, or throw"]}],nm:"character"}},$at:{hasMore:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:5,mt:"a",an:[{doc:["Whether there is another character"]}],nm:"hasMore"},position:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"position"},column_$7ybrm0:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1027,mt:"a",nm:"column_"},index$axh4m1:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"index"},column:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"column"},line_$j1cqe:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"line_"},line:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"line"},unexpectedEnd:{$t:{pk:".",nm:"ParseException"},pa:1,mt:"g",nm:"unexpectedEnd"}},nm:"Tokenizer"},JsonObject:{super:{pk:".",nm:"Object"},pa:1,mt:"c",an:[{doc:["Alternative name for [[Object]] which avoids collision with\nceylon.language::Object."]}],$alias:1,ps:[{$t:{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{md:"$",ta:{"Entry.Item":{pk:".",nm:"Value"},"Entry.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Entry"}},pk:"$",nm:"Iterable"},mt:"prm",nm:"values"}],nm:"JsonObject"},Value:{pa:1,mt:"als",an:[{doc:["A JSON value, a [[String]], [[Boolean]], [[Integer]],\n[[Float]], JSON [[Object]], JSON [[Array]], or \n[[Null]]."]}],$alias:{comp:"u",l:[{pk:".",nm:"ObjectValue"},{md:"$",pk:"$",nm:"Null"}]},nm:"Value"},StringTokenizer:{super:{pk:".",nm:"Tokenizer"},pa:1,mt:"c",an:[{doc:["An implementation of Tokenizer using a String"]}],$m:{character:{$t:{md:"$",pk:"$",nm:"Character"},pa:3,mt:"m",an:[{doc:["The character at the current index, or throw"]}],nm:"character"}},$at:{hasMore:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"g",an:[{doc:["Whether there is another character"]}],nm:"hasMore"},it$7u8mvj:{$t:{md:"$",ta:{"Iterator.Element":{md:"$",pk:"$",nm:"Character"}},pk:"$",nm:"Iterator"},mt:"a",nm:"it"},chars$3ibitv:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"chars"},count$8nuut1:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"count"},char$9u7k64:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Character"},{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Finished"}]}]},pa:1027,mt:"a",nm:"char"},size$zp8k7:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"a",nm:"size"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"chars"}],nm:"StringTokenizer"},parseDigit:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"c"}]],nm:"parseDigit"},StringPrinter:{super:{pk:".",nm:"Printer"},pa:1,mt:"c",an:[{doc:["A JSON Printer that prints to a [[String]]."]},{by:["Stéphane Épardaud"]}],$m:{print:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",an:[{doc:["Appends the given value to our `String` representation"]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"print"}},$at:{builder$4bb58c:{$t:{md:"$",pk:"$",nm:"StringBuilder"},mt:"a",nm:"builder"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:11,mt:"g",an:[{doc:["Returns the printed JSON"]}],nm:"string"},pretty$3cghnj:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"a",nm:"pretty"}},ps:[{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"pretty"}],nm:"StringPrinter"},parseNumber:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"}]},pa:1,mt:"m",an:[{doc:["Parse a number, consuming any initial whitespace."]}],ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],nm:"parseNumber"},Emitter:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,mt:"c",an:[{doc:["A [[Visitor]] which emits formatted \nJSON to the [[print]] method."]},{by:["Tom Bentley"]}],sts:[{pk:".",nm:"Visitor"}],$m:{onKey:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],nm:"onKey"},onBoolean:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",nm:"v"}]],nm:"onBoolean"},onStartObject:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",an:[{doc:["Prints an `Object`"]}],nm:"onStartObject"},onStartArray:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"onStartArray"},print:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Override to implement the printing part"]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"print"},onString:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"s"}]],nm:"onString"},onEndObject:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"onEndObject"},indent$dqjjny:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",nm:"indent"},onEndArray:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"onEndArray"},printString$38as7o:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",an:[{doc:["Prints a `String`"]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"s"}]],nm:"printString"},onNumber:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"}]},mt:"prm",nm:"n"}]],nm:"onNumber"},emitValue$jk96z8:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",an:[{doc:["Updates the top element on the stack, and \nadds comma separators if emitting an array."]}],nm:"emitValue"},onNull:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",nm:"onNull"}},$at:{pretty$8sysk4:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"a",nm:"pretty"},state$ilnlu7:{$t:{md:"ceylon.collection",ta:{"ArrayList.Element":{md:"$",pk:"$",nm:"Integer"}},pk:"ceylon.collection",nm:"ArrayList"},mt:"a",an:[{doc:["A stack of states. The top of the stack corresponds to the \ncurrent thing we're emitting. If it's > 0 we're emitting an Object,\nif it's < 0 we're emitting an Array. The magnitude -1 is the number \nof elements of the Object or Array that have been emitted so far."]}],nm:"state"},level$4mlxvu:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"g",nm:"level"}},ps:[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",nm:"pretty"}],nm:"Emitter"},parseStringUnicode:{$t:{md:"$",pk:"$",nm:"Character"},mt:"m",ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],nm:"parseStringUnicode"},Printer:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,mt:"c",an:[{doc:["A JSON Printer"]},{by:["Stéphane Épardaud"]}],$m:{printValue:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:9,mt:"m",an:[{doc:["Prints a JSON value"]}],ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],nm:"printValue"},printString:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:9,mt:"m",an:[{doc:["Prints a `String`"]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"s"}]],nm:"printString"},indent$1opgam:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",nm:"indent"},printBoolean:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:9,mt:"m",an:[{doc:["Prints a `Boolean`"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",nm:"v"}]],nm:"printBoolean"},printObject:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:9,mt:"m",an:[{doc:["Prints an `Object`"]}],ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"o"}]],nm:"printObject"},printArray:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:9,mt:"m",an:[{doc:["Prints an `Array`"]}],ps:[[{$t:{pk:".",nm:"Array"},mt:"prm",nm:"o"}]],nm:"printArray"},leave$jlu1e9:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",nm:"leave"},enter$lrxp1m:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",nm:"enter"},printNull:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:9,mt:"m",an:[{doc:["Prints `null`"]}],nm:"printNull"},printNumber:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:9,mt:"m",an:[{doc:["Prints an `Integer|Float`"]}],ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"}]},mt:"prm",nm:"n"}]],nm:"printNumber"},print:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Override to implement the printing part"]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"print"}},$at:{level$k1uxue:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"level"},pretty$6ma7eg:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"a",nm:"pretty"}},ps:[{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"pretty"}],nm:"Printer"},parseDigits:{$t:{md:"$",pk:"$",nm:"String"},mt:"m",ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"},{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",nm:"requireNonZeroFirstChar"}]],nm:"parseDigits"},InvalidTypeException:{super:{md:"$",pk:"$",nm:"Exception"},pa:1,mt:"c",an:[{doc:["Represents the failure of a type conversion.  \nAn instance is typically thrown as a result of trying to \nget and convert an [[Object]] member or [[Array]] element \nwhich cannot be converted to the requested or implied type."]}],$at:{message$jqbjmt:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"message"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"message"}],nm:"InvalidTypeException"},parseTrue:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,mt:"m",an:[{doc:["Parse true, consuming any initial whitespace"]}],ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],nm:"parseTrue"},"$pkg-anns":[{doc:["A JSON parser \/ serialiser"]},{by:["Stéphane Épardaud"]}]},"ceylon.json.stream":{buildObject:{$t:{pk:"ceylon.json",nm:"Object"},mt:"m",ps:[[{$t:{comp:"i",l:[{md:"$",ta:{"Iterator.Element":{pk:".",nm:"Event"}},pk:"$",nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"prm",nm:"events"}]],nm:"buildObject"},StreamParser:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["A parser for JSON data as specified by \n[RFC 7159] [1] which produces a stream of [[events|Event]] \nto be handled by the caller. The parser produces events as it reads the \nsource [[input]], so it's possible to start parsing JSON while it's \nstill being received.\n\nThis parser does not enforce uniqueness of keys within \nJSON objects. It is usually not onerous for the caller to do so if \nthey require such enforcement.\n\nBy default [[ParseException]]s will propagate out of calls to [[next]] \nwhen a error is detected. You can use [[errorReporting]] \nto report errors as [[Exception]]s within the stream.\n\n## Example\n\nSuppose we have the domain model:\n\n    class Order(address, items) {\n        shared String address;\n        shared Item[] items;\n    }\n    class Item(sku, quantity) {\n        shared String sku;\n        shared Integer quantity;\n    }\n    \n And we want to parse JSON that looks like this:\n \n ```javascript\n    {\n      \"address\":\"\",\n      \"items\":[\n        {\n          \"sku\":\"123-456-789\",\n          \"quantity\":4\n        },\n        {\n          \"sku\":\"456-789\",\n          \"quantity\":20\n        }\n      ]\n    }\n ```\n \n Then we might write a parser like this:\n \n     class OrderParser() {\n         \n         late variable LookAhead<Event> stream;\n        \n         String missingKey(String container, String key) {\n             return \"``container``: '``key``' missing at line ``stream.line``'\";\n         }\n         String duplicateKey(String container, String key) {\n             return \"``container``: '``key``' occurs more than once at line ``stream.line``'\";\n         }\n         String keyType(String container, String key, String expectedType) {\n             return \"``container``: '``key``' key is supposed to be of ``expectedType`` type at line ``stream.line``\";\n         }\n         String unexpectedKey(String container, String key) {\n             return \"``container``: '``key``' key not supported at line ``stream.line``\";\n         }\n         String unexpectedEvent(String container, Event|Finished event) {\n             return \"``container``: unexpected event ``event else \"null\"`` at line ``stream.line``\";\n         }\n         \n         \"Parses an item from events read from the given parser.\n          Returns the item or an error explanation.\"\n         Item|String parseItem() {\n             if (!(stream.next() is ObjectStartEvent)) {\n                 return \"Item: should be a JSON object\";\n             }\n             variable String? sku = null;\n             variable Integer? quantity = null;\n             while(true) {\n                 switch(event=stream.next())\n                 case (is KeyEvent) {\n                     switch(key=event.key) \n                     case (\"sku\") {\n                         if (is String s = stream.next()) {\n                             if (sku exists) {\n                                 return duplicateKey(\"Item\", \"sku\");\n                             }\n                             sku = s;\n                         } else {\n                             return keyType(\"Item\", \"sku\", \"String\");\n                         }\n                     }\n                     case (\"quantity\") {\n                         if (is Integer s = stream.next()) {\n                             if (quantity exists) {\n                                 return duplicateKey(\"Item\", \"quantity\");\n                             }\n                             quantity = s;\n                         } else {\n                             return keyType(\"Item\", \"sku\", \"Integer\");\n                         }\n                     }\n                     else {\n                         return unexpectedKey(\"Item\", key);\n                     }\n                 }\n                 case (is ObjectEndEvent) {\n                     if (exists s=sku) {\n                         if (exists q=quantity) {\n                             return Item(s, q);\n                         }\n                         return missingKey(\"Item\", \"quantity\");\n                     }\n                     return missingKey(\"Item\", \"sku\");\n                 }\n                 else {\n                     return unexpectedEvent(\"Item\", event);\n                 }\n             }\n         }\n         \n         \"Parses an order from events read from the given parser.\n          Returns the order or an error explanation.\"\n         Order|String parseOrder() {\n             if (!(stream.next() is ObjectStartEvent)) {\n                 return \"Order: should be a JSON object\";\n             }\n             variable String? address = null;\n             value items = ArrayList<Item>();\n             while(true) {\n                 switch(event=stream.next())\n                 case (is KeyEvent) {\n                     switch(key=event.key) \n                     case (\"address\") {\n                         if (is String s = stream.next()) {\n                             if (address exists) {\n                                 return duplicateKey(\"Order\", \"address\");\n                             }\n                             address = s;\n                         } else {\n                             return keyType(\"Order\", \"address\", \"String\");\n                         }\n                     }\n                     case (\"items\") {\n                         if (!items.empty) {\n                             return duplicateKey(\"Order\", \"items\");\n                         }\n                         if (!stream.next() is ArrayStartEvent) {\n                             return keyType(\"Order\", \"items\", \"Array\");\n                         }\n                         while (stream.peek() is ObjectStartEvent) {\n                             switch (item=parseItem())\n                             case (is String) {\n                                 return item;\n                             }\n                             case (is Item) {\n                                 items.add(item);\n                             }\n                         }\n                         assert(stream.next() is ArrayEndEvent);\n                     }\n                     else {\n                         return unexpectedKey(\"Order\", key);\n                     }\n                 }\n                 case (is ObjectEndEvent) {\n                     if (exists a=address) {\n                         return Order(a, items.sequence());\n                     }\n                     return missingKey(\"Order\", \"address\");\n                 }\n                 else {\n                     return unexpectedEvent(\"Item\", event);\n                 }\n             }\n         }\n         \n         shared Order|String parse(String json) {\n             stream = LookAhead(StreamParser(StringTokenizer(json)));\n             return parseOrder();\n         }\n     }\n\nWhile this is certainly verbose it's extremely readable and regular.\n\n[1]: https:\/\/tools.ietf.org\/html\/rfc7159\n"]}],sts:[{md:"$",ta:{"Iterator.Element":{pk:".",nm:"Event"}},pk:"$",nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}],$m:{checkNext$rguf2k:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"expectedIdent"}]],nm:"checkNext"},yield$38y73i:{$t:{comp:"u",l:[{pk:".",nm:"Event"},{md:"$",pk:"$",nm:"Finished"}]},mt:"m",ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Event"},{md:"$",pk:"$",nm:"Finished"}]},mt:"prm",nm:"yielding"}]],nm:"yield"},next:{$t:{comp:"u",l:[{pk:".",nm:"Event"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",an:[{doc:["Return the next event from the stream, or finished"]},{throws:["ParseException"]}],nm:"next"},parseValue$abikp:{$t:{pk:".",nm:"Event"},mt:"m",an:[{doc:["Parse any JSON value and return an event"]}],nm:"parseValue"},pushState$9cmfiw:{$t:{pk:".",nm:"StreamState"},mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"StreamState"}]},mt:"prm",nm:"parent"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Event"}]},mt:"prm",nm:"last"}]],nm:"pushState"}},$at:{position:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"position"},state$r6yb4i:{$t:{pk:".",nm:"StreamState"},pa:1027,mt:"a",an:[{doc:["A stack (singly linked list) of states for all objects and arrays which \nhave been started, but not finished."]}],nm:"state"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"},input$rh2j6r:{$t:{pk:"ceylon.json",nm:"Tokenizer"},mt:"a",an:[{doc:["The tokenizer to read input from"]}],nm:"input"},column:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"column"},trackKeys$4hlw5s:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"a",an:[{doc:["Whether to validate the uniqueness of keys"]}],nm:"trackKeys"},line:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"line"}},ps:[{$t:{pk:"ceylon.json",nm:"Tokenizer"},mt:"prm",an:[{doc:["The tokenizer to read input from"]}],$hdn:1,nm:"input"},{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",an:[{doc:["Whether to validate the uniqueness of keys"]}],$hdn:1,nm:"trackKeys"}],nm:"StreamParser"},StreamingVisitor:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["Produces a stream of events from the descendents of the given root value."]}],sts:[{md:"$",ta:{"Iterator.Element":{pk:".",nm:"Event"}},pk:"$",nm:"Iterator"}],$m:{next:{$t:{comp:"u",l:[{pk:".",nm:"Event"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},$at:{stack$vozhl2:{$t:{md:"ceylon.collection",ta:{"ArrayList.Element":{ta:{"PushIterator.T":{comp:"u",l:[{pk:"ceylon.json",nm:"Value"},{md:"$",ta:{"Entry.Item":{pk:"ceylon.json",nm:"Value"},"Entry.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Entry"}]}},pk:".",nm:"PushIterator"}},pk:"ceylon.collection",nm:"ArrayList"},mt:"a",nm:"stack"},pi$wvgdfz:{$t:{ta:{"PushIterator.T":{comp:"u",l:[{pk:"ceylon.json",nm:"Value"},{md:"$",ta:{"Entry.Item":{pk:"ceylon.json",nm:"Value"},"Entry.Key":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Entry"}]}},pk:".",nm:"PushIterator"},mt:"a",nm:"pi"},root$tvqdbk:{$t:{pk:"ceylon.json",nm:"Value"},mt:"a",nm:"root"}},ps:[{$t:{pk:"ceylon.json",nm:"Value"},mt:"prm",nm:"root"}],nm:"StreamingVisitor"},objectStart:{super:{pk:".",nm:"ObjectStartEvent"},pa:1,mt:"o",an:[{doc:["The start of an object encountered when processing JSON data"]}],$at:{other:{$t:{pk:".",nm:"ObjectEndEvent"},pa:3,mt:"g",nm:"other"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"objectStart"},PushIterator:{super:{md:"$",pk:"$",nm:"Basic"},mt:"c",sts:[{md:"$",ta:{"Iterator.Element":{nm:"T"}},pk:"$",nm:"Iterator"}],tp:[{dv:"out",nm:"T"}],$m:{next:{$t:{comp:"u",l:[{nm:"T"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"},push:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:1,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Anything"},mt:"prm",nm:"pushed"}]],nm:"push"}},$at:{pushed$3u4iln:{$t:{comp:"u",l:[{nm:"T"},{pk:".",nm:"None"}]},pa:1027,mt:"a",nm:"pushed"},it$vje6a5:{$t:{md:"$",ta:{"Iterator.Element":{nm:"T"}},pk:"$",nm:"Iterator"},mt:"a",nm:"it"}},ps:[{$t:{md:"$",ta:{"Iterator.Element":{nm:"T"}},pk:"$",nm:"Iterator"},mt:"prm",nm:"it"}],nm:"PushIterator"},ArrayStartEvent:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"arrayStart"}],pa:257,mt:"c",an:[{doc:["The start of a JSON array, emitted when `[` is parsed."]}],sts:[{ta:{"NestingEvent.Other":{pk:".",nm:"ArrayEndEvent"},"NestingEvent.Self":{pk:".",nm:"ArrayStartEvent"}},pk:".",nm:"NestingEvent"}],nm:"ArrayStartEvent"},streamToVisitor:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:1,mt:"m",an:[{doc:["Calls a visitor according to the events obtained from a stream."]}],ps:[[{$t:{md:"$",ta:{"Iterator.Element":{pk:".",nm:"Event"}},pk:"$",nm:"Iterator"},mt:"prm",nm:"stream"},{$t:{pk:"ceylon.json",nm:"Visitor"},mt:"prm",nm:"visitor"}]],nm:"streamToVisitor"},arrayStart:{super:{pk:".",nm:"ArrayStartEvent"},pa:1,mt:"o",an:[{doc:["The start of an array encountered when processing JSON data"]}],$at:{other:{$t:{pk:".",nm:"ArrayEndEvent"},pa:3,mt:"g",nm:"other"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"arrayStart"},errorReporting:{$t:{comp:"i",l:[{md:"$",ta:{"Iterator.Element":{comp:"u",l:[{nm:"T"},{md:"$",pk:"$",nm:"Exception"}]}},pk:"$",nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"m",an:[{doc:["Adapts the given stream so that exceptions thrown while evaluating `next()` get \nreturned from the iterator, rather than propagating."]}],tp:[{nm:"T"}],ps:[[{$t:{comp:"i",l:[{md:"$",ta:{"Iterator.Element":{nm:"T"}},pk:"$",nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"prm",nm:"stream"}]],nm:"errorReporting"},buildArray:{$t:{pk:"ceylon.json",nm:"Array"},mt:"m",ps:[[{$t:{comp:"i",l:[{md:"$",ta:{"Iterator.Element":{pk:".",nm:"Event"}},pk:"$",nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"prm",nm:"events"}]],nm:"buildArray"},none:{super:{pk:".",nm:"None"},mt:"o",nm:"none"},None:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"none"}],pa:256,mt:"c",an:[{doc:["A unit type used internally because we can't use null"]}],nm:"None"},parse:{$t:{pk:"ceylon.json",nm:"Value"},mt:"m",an:[{doc:["Parse the given string of JSON \nformatted data into an in-memory model, \nreturning the model."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"json"}]],nm:"parse"},objectEnd:{super:{pk:".",nm:"ObjectEndEvent"},pa:1,mt:"o",an:[{doc:["The end of the current object encountered when processing JSON data"]}],$at:{other:{$t:{pk:".",nm:"ObjectStartEvent"},pa:3,mt:"g",nm:"other"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"objectEnd"},arrayEnd:{super:{pk:".",nm:"ArrayEndEvent"},pa:1,mt:"o",an:[{doc:["The end of the current array encountered when processing JSON data"]}],$at:{other:{$t:{pk:".",nm:"ArrayStartEvent"},pa:3,mt:"g",nm:"other"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"arrayEnd"},"$pkg-pa":1,KeyEvent:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["A key encountered when processing JSON data"]}],$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"},key:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"key"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",$hdn:1,nm:"key"}],nm:"KeyEvent"},Event:{pa:1,mt:"als",an:[{doc:["An event encountered when processing JSON data"]}],$alias:{comp:"u",l:[{pk:".",nm:"ObjectStartEvent"},{pk:".",nm:"ObjectEndEvent"},{pk:".",nm:"ArrayStartEvent"},{pk:".",nm:"ArrayEndEvent"},{pk:".",nm:"KeyEvent"},{md:"$",pk:"$",nm:"String"},{md:"$",pk:"$",nm:"Float"},{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Boolean"},{md:"$",pk:"$",nm:"Null"}]},nm:"Event"},StreamState:{super:{md:"$",pk:"$",nm:"Basic"},mt:"c",an:[{doc:["Package-private class used by [[StreamParser]] to track state."]}],$at:{num:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1025,mt:"a",an:[{doc:["The number of events yielded so far"]}],nm:"num"},last:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Event"}]},pa:1025,mt:"a",nm:"last"},keys:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"ceylon.collection",ta:{"HashSet.Element":{md:"$",pk:"$",nm:"String"}},pk:"ceylon.collection",nm:"HashSet"}]},pa:1,mt:"a",nm:"keys"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"},parent:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"StreamState"}]},pa:1,mt:"a",nm:"parent"}},ps:[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"StreamState"}]},pa:1,mt:"prm",$hdn:1,nm:"parent"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Event"}]},pa:1025,mt:"prm",$hdn:1,nm:"last"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"ceylon.collection",ta:{"HashSet.Element":{md:"$",pk:"$",nm:"String"}},pk:"ceylon.collection",nm:"HashSet"}]},pa:1,mt:"prm",$hdn:1,nm:"keys"}],nm:"StreamState"},buildValue:{$t:{pk:"ceylon.json",nm:"Value"},mt:"m",an:[{doc:["Recursively builds a [[model|Value]] from events produced from the given iterator."]}],ps:[[{$t:{comp:"i",l:[{md:"$",ta:{"Iterator.Element":{pk:".",nm:"Event"}},pk:"$",nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"prm",nm:"events"}]],nm:"buildValue"},ObjectStartEvent:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"objectStart"}],pa:257,mt:"c",an:[{doc:["The start of a JSON object\/hash, emitted when `{` is parsed."]}],sts:[{ta:{"NestingEvent.Other":{pk:".",nm:"ObjectEndEvent"},"NestingEvent.Self":{pk:".",nm:"ObjectStartEvent"}},pk:".",nm:"NestingEvent"}],nm:"ObjectStartEvent"},NestingEvent:{pa:17,mt:"i",an:[{doc:["An [[Event]] that has a corresponding other event"]}],tp:[{sts:[{ta:{"NestingEvent.Other":{nm:"Other"},"NestingEvent.Self":{nm:"Self"}},pk:".",nm:"NestingEvent"}],nm:"Self"},{dv:"out",sts:[{ta:{"NestingEvent.Other":{nm:"Self"},"NestingEvent.Self":{nm:"Other"}},pk:".",nm:"NestingEvent"}],nm:"Other"}],$at:{other:{$t:{nm:"Other"},pa:5,mt:"a",an:[{doc:["The value associated with this event"]}],nm:"other"}},nm:"NestingEvent"},LookAhead:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["A look-ahead buffer wrapping a stream"]}],sts:[{md:"$",ta:{"Iterator.Element":{nm:"T"}},pk:"$",nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}],tp:[{nm:"T"}],$m:{next:{$t:{comp:"u",l:[{nm:"T"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"},peek:{$t:{comp:"u",l:[{nm:"T"},{md:"$",pk:"$",nm:"Finished"}]},pa:1,mt:"m",an:[{doc:["Get the *n*th element ahead"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"n"}]],nm:"peek"}},$at:{position:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"position"},lin$k41cb1:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1155,mt:"a",an:[{doc:["The line number of the last element returned from next()"]}],nm:"lin"},lookAhead$xft3nu:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},mt:"a",an:[{doc:["The maximum number of elements we can look ahead, or null for unbounded lookahead."]}],nm:"lookAhead"},pos$k7bql4:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1155,mt:"a",an:[{doc:["The position of the last element returned from next()"]}],nm:"pos"},peeked$1afwi6:{$t:{md:"ceylon.collection",ta:{"ArrayList.Element":{comp:"u",l:[{nm:"T"},{md:"$",pk:"$",nm:"Finished"}]}},pk:"ceylon.collection",nm:"ArrayList"},mt:"a",an:[{doc:["The buffer"]}],nm:"peeked"},column:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"column"},line:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"line"},col$jx4yhw:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1155,mt:"a",an:[{doc:["The column number of the last element returned from next()"]}],nm:"col"},stream$4v9nbw:{$t:{comp:"i",l:[{md:"$",ta:{"Iterator.Element":{nm:"T"}},pk:"$",nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"a",nm:"stream"}},ps:[{$t:{comp:"i",l:[{md:"$",ta:{"Iterator.Element":{nm:"T"}},pk:"$",nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"prm",nm:"stream"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},def:1,mt:"prm",an:[{doc:["The maximum number of elements we can look ahead, or null for unbounded lookahead."]}],$hdn:1,nm:"lookAhead"}],nm:"LookAhead"},ObjectEndEvent:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"objectEnd"}],pa:257,mt:"c",an:[{doc:["The end of a JSON object\/hash, emitted when `}` is parsed."]}],sts:[{ta:{"NestingEvent.Other":{pk:".",nm:"ObjectStartEvent"},"NestingEvent.Self":{pk:".",nm:"ObjectEndEvent"}},pk:".",nm:"NestingEvent"}],nm:"ObjectEndEvent"},ArrayEndEvent:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"arrayEnd"}],pa:257,mt:"c",an:[{doc:["The end of a JSON array, emitted when `]` is parsed."]}],sts:[{ta:{"NestingEvent.Other":{pk:".",nm:"ArrayStartEvent"},"NestingEvent.Self":{pk:".",nm:"ArrayEndEvent"}},pk:".",nm:"NestingEvent"}],nm:"ArrayEndEvent"},"$pkg-anns":[{doc:["Representation of JSON data as [[events|Event]] pulled from an [[Iterator]].\n\n[[StreamParser]] produces events according to JSON data read from \na [[ceylon.json::Tokenizer]].\n\n[[errorReporting]] adapts an Iterator so that exceptions thrown \nwhile iterating are *returned from* the iterator, rather \nthan *propagating from* it.\n\n[[streamToVisitor]] provides a bridge between producers of events \n(in the form of `Iterator`s) and consumers of those events (in the form \nof a [[ceylon.json::Visitor]].\n\n[[StreamingVisitor]] provides a bridge in the reverse direction. \nIt can be used to produce events by \n[[visiting|ceylon.json::visit]] a [[ceylon.json::Value]]."]}]}};
});
}(typeof define==='function' && define.amd ? define : function (factory) {
if (typeof exports!=='undefined') { factory(require, exports, module);
} else { throw 'no module loader'; }
}));
