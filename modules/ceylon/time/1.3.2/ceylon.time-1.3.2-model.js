(function(define) { define(function(require, ex$, module) {
ex$.$CCMM$={"$mod-name":"ceylon.time","$mod-deps":["ceylon.language\/1.3.2"],"$mod-version":"1.3.2","ceylon.time.internal.math":{floorDiv:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns floored division of the two integers."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"x"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"y"}]],nm:"floorDiv"},floor:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns the largest integer less than or equal to _x_."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Float"},mt:"prm",nm:"x"}]],nm:"floor"},round:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns nearest integer to x"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Float"},mt:"prm",nm:"f"}]],nm:"round"},adjustedMod:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns an _adjusted remainder_ of the two integers.\n\n   value moduli = [for (x in 4..-4) amod(x, 4)];\n   assert( moduli == [4, 3, 2, 1, 4, 3, 2, 1, 4] );\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"x"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"y"}]],nm:"adjustedMod"},floorMod:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns the floor remainder (modulus) of the two integers.\n\n    value moduli = [for (x in 4..-4) mod(x, 4)] \n    assert( moduli == [0, 3, 2, 1, 0, 3, 2, 1, 0] );\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"x"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"y"}]],nm:"floorMod"},"$pkg-anns":[{by:["Diego Coronel","Roland Tepp"]}],"$pkg-pa":1},"ceylon.time.chronology":{LeapYear:{of:[{nm:"Self"}],pa:1,mt:"i",an:[{doc:["An interface for calendar system that defines leap year rules.\n\n*Note:* This interface is meant to convey a Calendar that has some sort of leap year syntax."]}],sts:[{ta:{"Chronology.Fields":{nm:"Fields"}},pk:".",nm:"Chronology"}],tp:[{sts:[{ta:{"Chronology.Fields":{nm:"Fields"}},pk:".",nm:"Chronology"}],nm:"Self"},{sts:[{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Anything"}},pk:"$",nm:"Sequential"}],nm:"Fields"}],st:"Self",$m:{leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:5,mt:"m",an:[{doc:["Returns true if the specified year is a leap year according to the leap year rules of the given chronology."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"leapYear"}]],nm:"leapYear"}},nm:"LeapYear"},unixTime:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"o",an:[{doc:["Common properties of _Unix time_."]}],$m:{fixedFromTime:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns a _fixed date_ from the _unix time_ value."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"time"}]],nm:"fixedFromTime"},timeOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns _time of day_ in milliseconds for the specified _unix time_ value."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"time"}]],nm:"timeOfDay"},timeFromFixed:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Return milliseconds elapsed from 1970-01-01 00:00:00."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"date"}]],nm:"timeFromFixed"}},$at:{epoch:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:[{doc:["Fixed date value of the _Unix time_ epoch (1970-01-01)."]}],nm:"epoch"}},nm:"unixTime"},gregorian:{super:{pk:".",nm:"GregorianCalendar"},pa:1,mt:"o",an:[{doc:["Represents the implementation of all calculations for\nthe rules based on Gregorian Calendar."]}],$m:{fixedFrom:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",an:[{doc:["Return the _day of era_ from a given date."]}],ps:[[{$t:{count:3,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},mt:"prm",nm:"date"}]],nm:"fixedFrom"},fixed$jr0536:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"m",an:[{doc:["Return the _day of era_ from a given date."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"month"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"day"}]],nm:"fixed"},yearEnd:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns fixed date value of the last day of the gregorian year."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],nm:"yearEnd"},dayOfWeekFrom:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns _day of week_ value for the specified fixed date value."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"date"}]],nm:"dayOfWeekFrom"},monthFrom:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns the month number of the gregorian calendar from the fixed date value."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"date"}]],nm:"monthFrom"},newYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns fixed date value of the first day of the gregorian year."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],nm:"newYear"},checkDate:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",an:[{doc:["Assert that specified date has it conjunction of year, month and day as valid gregorian values."]}],ps:[[{$t:{count:3,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},mt:"prm",nm:"date"}]],nm:"checkDate"},yearFrom:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns a gregorian year number of the fixed date value."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"fixed"}]],nm:"yearFrom"},dayFrom:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns day of month value of the fixed date value."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"date"}]],nm:"dayFrom"},leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",an:[{doc:["Gregorian leap year rule states that every fourth year\nis a leap year except century years not divisible by 400."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],nm:"leapYear"},dateFrom:{$t:{count:3,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},pa:3,mt:"m",an:[{doc:["Converts the fixed date value to an equivalent gregorian date."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"date"}]],nm:"dateFrom"}},$at:{december:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"december"},november:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"november"},may:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"may"},march:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"march"},april:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"april"},february:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"february"},june:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"june"},january:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"january"},epoch:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{doc:["Epoch of the gregorian calendar."]}],nm:"epoch"},august:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"august"},july:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"july"},october:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"october"},september:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"september"}},nm:"gregorian"},Chronology:{pa:1,mt:"i",an:[{doc:["Generic base interface of a _calendar system_.\nChronology serves as a computational backend to \na Date representation of the same calendar system."]}],tp:[{sts:[{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Anything"}},pk:"$",nm:"Sequential"}],nm:"Fields"}],$m:{fixedFrom:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",an:[{doc:["Converts date tuple of this calendar system to an equivalent _fixed date_\nrepresentation of the day of era."]}],ps:[[{$t:{nm:"Fields"},mt:"prm",nm:"date"}]],nm:"fixedFrom"},checkDate:{$ff:1,$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:[{doc:["Validate the given date."]}],ps:[[{$t:{nm:"Fields"},mt:"prm",nm:"date"}]],nm:"checkDate"},dateFrom:{$t:{nm:"Fields"},pa:5,mt:"m",an:[{doc:["Converts a _fixed day_ number to a calendar date tuple."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"fixed"}]],nm:"dateFrom"}},$at:{epoch:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Epoch is the offset of the _fixed date_ day number that defines \nthe beginning of the calendar."]}],nm:"epoch"}},nm:"Chronology"},rd:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Converts _Rata Die_ day number to a fixed date value.\n\n_Rata Die_ is fixed at Monday, January 1st, 1. (Gregorian)."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"t"}]],nm:"rd"},"$pkg-anns":[{doc:["Package containing supported chronologies in ceylon.time library.\n\nA _Chronology_ is a set of functions and methods that define the calendar system. \nA Chronology is tightly coupled to the actual date implementation of that chronology.\n\nGenerally speaking, a chronology is an implementation detail of a calendar system that \nshould not be overly visible to the users of the library unless they wish to implement \ntheir own calendrical systems.\n\nInitial implementation contains only implementation for gregorian (and julian) chronologies. \nThis API is considered experimental and can change significantly between releases, so dependency \non this package is not advisable for general use.\n"]},{by:["Diego Coronel","Roland Tepp"]}],"$pkg-pa":1,GregorianCalendar:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"gregorian"}],pa:257,mt:"c",an:[{doc:["Base class for a gregorian calendar chronology."]}],sts:[{ta:{"Chronology.Fields":{count:3,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"}},pk:".",nm:"Chronology"},{ta:{"LeapYear.Self":{pk:".",nm:"GregorianCalendar"},"LeapYear.Fields":{count:3,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"}},pk:".",nm:"LeapYear"}],nm:"GregorianCalendar"}},"ceylon.time":{Period:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["An immutable period consisting of the ISO-8601 _years_, _months_, _days_, _hours_,\n_minutes_, _seconds_ and _milliseconds_, such as '3 Months, 4 Days and 7 Hours'.\n\nA period is a human-scale description of an amount of time.\n"]}],sts:[{pk:"ceylon.time.base",nm:"ReadablePeriod"},{pk:"ceylon.time.base",nm:"ReadableTimePeriod"},{pk:"ceylon.time.base",nm:"ReadableDatePeriod"},{ta:{"PeriodBehavior.Self":{pk:".",nm:"Period"}},pk:"ceylon.time.base",nm:"PeriodBehavior"},{md:"$",ta:{"Comparable.Other":{pk:".",nm:"Period"}},pk:"$",nm:"Comparable"},{md:"$",ta:{"Summable.Other":{pk:".",nm:"Period"}},pk:"$",nm:"Summable"},{md:"$",ta:{"Scalable.Scale":{md:"$",pk:"$",nm:"Integer"},"Scalable.Value":{pk:".",nm:"Period"}},pk:"$",nm:"Scalable"}],$m:{scale:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Each field will be scalable independently, and the result will _not_ be normalized"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"scale"}]],nm:"scale"},withMilliseconds:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of milliseconds."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"withMilliseconds"},plusDays:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of days added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"plusDays"},withMinutes:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of minutes."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"withMinutes"},withDays:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of days."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"withDays"},minusHours:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of hours subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"minusHours"},plusSeconds:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of seconds added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"plusSeconds"},minusMilliseconds:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of milliseconds subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"minusMilliseconds"},withSeconds:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of seconds."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"withSeconds"},plusMinutes:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of minutes added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"plusMinutes"},plus:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a new period that is a sum of the two periods."]}],ps:[[{$t:{pk:".",nm:"Period"},mt:"prm",nm:"other"}]],nm:"plus"},normalized:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with all amounts normalized to the\nstandard ranges for date\/time fields.\n\nTwo normalizations occur, one for years and months, and one for\nhours, minutes, seconds and milliseconds.\n\nDays are not normalized, as a day may vary in length at daylight savings cutover.\nNeither is days normalized into months, as number of days per month varies from\nmonth to another and depending on the leap year."]}],nm:"normalized"},withYears:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of years."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"withYears"},minusSeconds:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of seconds subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"minusSeconds"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",an:[{doc:["Checks if this period is equal to another period."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,mt:"m",an:[{doc:["Return the result of comparing this period to the _other_ period."]}],ps:[[{$t:{pk:".",nm:"Period"},mt:"prm",nm:"other"}]],nm:"compare"},minusMinutes:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of minutes subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"minusMinutes"},minusYears:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of years subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"minusYears"},plusHours:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of hours added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"plusHours"},minusDays:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of days subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"minusDays"},withMonths:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of months."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"withMonths"},minusMonths:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of months subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"minusMonths"},plusMonths:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of months added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"plusMonths"},plusMilliseconds:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of milliseconds added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"plusMilliseconds"},plusYears:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of years added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"plusYears"},withHours:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of hours."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"withHours"},isZero:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,mt:"m",an:[{doc:["Checks if this period is zero-length."]}],nm:"isZero"}},$at:{months:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{doc:["The number of months."]}],nm:"months"},dateOnly:{$t:{pk:"ceylon.time.base",nm:"ReadableDatePeriod"},pa:3,mt:"g",an:[{doc:["Returns a date only view of this period."]}],nm:"dateOnly"},minutes:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{doc:["The number of minutes."]}],nm:"minutes"},days:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{doc:["The number of days."]}],nm:"days"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]}],nm:"hash"},seconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{doc:["The number of seconds."]}],nm:"seconds"},hours:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{doc:["The number of hours."]}],nm:"hours"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:[{doc:["Returns the ISO-8601 formatted string for this period."]}],nm:"string"},timeOnly:{$t:{pk:"ceylon.time.base",nm:"ReadableTimePeriod"},pa:3,mt:"g",an:[{doc:["Returns a time only view of this period."]}],nm:"timeOnly"},years:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{doc:["The number of years."]}],nm:"years"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{doc:["The number of milliseconds."]}],nm:"milliseconds"}},ps:[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,pa:3,mt:"prm",an:[{doc:["The number of years."]}],$hdn:1,nm:"years"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,pa:3,mt:"prm",an:[{doc:["The number of months."]}],$hdn:1,nm:"months"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,pa:3,mt:"prm",an:[{doc:["The number of days."]}],$hdn:1,nm:"days"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,pa:3,mt:"prm",an:[{doc:["The number of hours."]}],$hdn:1,nm:"hours"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,pa:3,mt:"prm",an:[{doc:["The number of minutes."]}],$hdn:1,nm:"minutes"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,pa:3,mt:"prm",an:[{doc:["The number of seconds."]}],$hdn:1,nm:"seconds"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,pa:3,mt:"prm",an:[{doc:["The number of milliseconds."]}],$hdn:1,nm:"milliseconds"}],nm:"Period"},dateTime:{$t:{pk:".",nm:"DateTime"},pa:1,mt:"m",an:[{doc:["Returns a date based on the specified year, month and day of month values."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:"ceylon.time.base",nm:"Month"}]},mt:"prm",nm:"month"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"day"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"hours"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"minutes"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"seconds"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"milliseconds"}]],nm:"dateTime"},today:{$t:{pk:".",nm:"Date"},pa:1,mt:"m",an:[{doc:["Returns current date according to the provided system clock and time zone."]}],ps:[[{$t:{pk:".",nm:"Clock"},def:1,mt:"prm",nm:"clock"},{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],nm:"today"},Clock:{pa:1,mt:"i",an:[{doc:["A clock providing access to the current instant, date and time using a time-zone.\n\nInstances of this class are used to find the current instant, which can be\ninterpreted using the stored time-zone to find the current date and time.\nAs such, a clock can be used instead of `system.milliseconds`.\n\nThe primary purpose of this abstraction is to allow alternate clocks to be\nplugged in as and when required. Applications use an object to obtain the\ncurrent time rather than a static method. This can simplify testing.\n\nApplications should _avoid_ using the top level objects directly.\nInstead, they should pass a [[Clock]] into any method that requires it.\nA dependency injection framework is one way to achieve this.\n\nThis approach allows an alternate clock, such as [[fixedTime]] to be used during testing.\n\nThe [[systemTime]] top level factory method offers clocks based on the best available \nsystem clock, such as `system.milliseconds`."]}],$m:{instant:{$t:{pk:".",nm:"Instant"},pa:5,mt:"m",an:[{doc:["Gets the current instant of the clock."]}],nm:"instant"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",an:[{doc:["Gets the current millisecond instant of the clock."]}],nm:"milliseconds"}},nm:"Clock"},date:{$t:{pk:".",nm:"Date"},pa:1,mt:"m",an:[{doc:["Returns a date based on the specified year, month and day of month values."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:"ceylon.time.base",nm:"Month"}]},mt:"prm",nm:"month"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"day"}]],nm:"date"},zero:{$t:{pk:".",nm:"Period"},pa:1,mt:"a",an:[{doc:["A period of zero length."]}],nm:"zero"},systemTime:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"o",an:[{doc:["Gets a clock that obtains the current instant using the best available system clock."]}],sts:[{pk:".",nm:"Clock"}],$m:{instant:{$t:{pk:".",nm:"Instant"},pa:3,mt:"m",an:[{doc:["Return current instant from system time."]}],nm:"instant"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",an:[{doc:["Return number of milliseconds from system time."]}],nm:"milliseconds"}},$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",an:[{doc:["Returns only the kind of this implementation as time can change to every call."]}],nm:"string"}},nm:"systemTime"},time:{$t:{pk:".",nm:"Time"},pa:1,mt:"m",an:[{doc:["Creates new instance of [[Time]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",an:[{doc:["Hours of the day (0..23)."]}],$hdn:1,nm:"hours"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",an:[{doc:["Minutes of the hour (0..59)."]}],$hdn:1,nm:"minutes"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",an:[{doc:["Seconds of the minute (0..59)."]}],$hdn:1,nm:"seconds"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",an:[{doc:["Milliseconds of the second (0..999)."]}],$hdn:1,nm:"milliseconds"}]],nm:"time"},Time:{pa:1,mt:"i",an:[{doc:["Time of day like _6pm_ or _8.30am_.\n\nThis type contains only information about an abstract _time of day_ without \nreferencing any date or timezone.\n\nYou use Time to specify something that has to occur on a specific time of day\nlike _\"lunch hour starts at 1pm\"_ or _\"shop opens at 10am\"_.\n"]}],sts:[{pk:"ceylon.time.base",nm:"ReadableTime"},{ta:{"TimeBehavior.Element":{pk:".",nm:"Time"}},pk:"ceylon.time.base",nm:"TimeBehavior"},{md:"$",ta:{"Comparable.Other":{pk:".",nm:"Time"}},pk:"$",nm:"Comparable"},{md:"$",ta:{"Ordinal.Other":{pk:".",nm:"Time"}},pk:"$",nm:"Ordinal"},{md:"$",ta:{"Enumerable.Other":{pk:".",nm:"Time"}},pk:"$",nm:"Enumerable"}],$m:{plus:{$t:{pk:".",nm:"Time"},pa:5,mt:"m",an:[{doc:["Adds a period of time to this time of day value.\n\nResult of this operation is another time of day,\nwrapping around 12 a.m. (midnight) if necessary.\n"]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableTimePeriod"},mt:"prm",nm:"period"}]],nm:"plus"},minus:{$t:{pk:".",nm:"Time"},pa:5,mt:"m",an:[{doc:["Subtracts a period of time to this time of day value.\n\nResult of this operation is another time of day,\nwrapping around 12 a.m. (midnight) if necessary.\n"]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableTimePeriod"},mt:"prm",nm:"period"}]],nm:"minus"},rangeTo:{$t:{pk:".",nm:"TimeRange"},pa:5,mt:"m",an:[{doc:["Returns the [[TimeRange]] between this and given Time."]}],ps:[[{$t:{pk:".",nm:"Time"},mt:"prm",nm:"other"}]],nm:"rangeTo"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:11,mt:"m",an:[{doc:["Two `Time`s are considered equals if they the same _milliseconds of day_."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"},periodTo:{$t:{pk:".",nm:"Period"},pa:5,mt:"m",an:[{doc:["Returns the period between this and the given time.\nIf this time is after the given time then return zero period."]}],ps:[[{$t:{pk:".",nm:"Time"},mt:"prm",nm:"end"}]],nm:"periodTo"},periodFrom:{$t:{pk:".",nm:"Period"},pa:5,mt:"m",an:[{doc:["Returns the period between this and the given time.\nIf this time is before the given time then return zero period."]}],ps:[[{$t:{pk:".",nm:"Time"},mt:"prm",nm:"start"}]],nm:"periodFrom"}},$at:{hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Implementation compatible with [[equals]] method.\n\nThis implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]}],nm:"hash"}},nm:"Time"},Date:{pa:1,mt:"i",an:[{doc:["An interface for date objects in the ISO-8601 calendar system.\n\nA date is often viewed as triple of year-month-day values. \nThis interface also defines access to other date fields such as \nday-of-year, day-of-week and week-of-year."]}],sts:[{pk:"ceylon.time.base",nm:"ReadableDate"},{ta:{"DateBehavior.Element":{pk:".",nm:"Date"}},pk:"ceylon.time.base",nm:"DateBehavior"},{md:"$",ta:{"Ordinal.Other":{pk:".",nm:"Date"}},pk:"$",nm:"Ordinal"},{md:"$",ta:{"Comparable.Other":{pk:".",nm:"Date"}},pk:"$",nm:"Comparable"},{md:"$",ta:{"Enumerable.Other":{pk:".",nm:"Date"}},pk:"$",nm:"Enumerable"}],$m:{plus:{$t:{pk:".",nm:"Date"},pa:5,mt:"m",an:[{doc:["Adds a specified period to this date."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableDatePeriod"},mt:"prm",nm:"period"}]],nm:"plus"},minus:{$t:{pk:".",nm:"Date"},pa:5,mt:"m",an:[{doc:["Subtracts a specified period to this date."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableDatePeriod"},mt:"prm",nm:"period"}]],nm:"minus"},rangeTo:{$t:{pk:".",nm:"DateRange"},pa:5,mt:"m",an:[{doc:["Returns the [[DateRange]] between this and given [[Date]]."]}],ps:[[{$t:{pk:".",nm:"Date"},mt:"prm",nm:"other"}]],nm:"rangeTo"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:11,mt:"m",an:[{doc:["Checks if this date is equal to another date.\n\nCompares this Date with another ensuring that the date both objects refer to is the same."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"},periodTo:{$t:{pk:".",nm:"Period"},pa:5,mt:"m",an:[{doc:["Returns the period between this and the given date.\n\nIf this date is after the given date then return zero period."]}],ps:[[{$t:{pk:".",nm:"Date"},mt:"prm",nm:"end"}]],nm:"periodTo"},at:{$t:{pk:".",nm:"DateTime"},pa:5,mt:"m",an:[{doc:["Returns new DateTime value based on this date and a specified time."]}],ps:[[{$t:{pk:".",nm:"Time"},mt:"prm",nm:"time"}]],nm:"at"},periodFrom:{$t:{pk:".",nm:"Period"},pa:5,mt:"m",an:[{doc:["Returns the period between this and the given date.\n\nIf this date is before the given date then return zero period."]}],ps:[[{$t:{pk:".",nm:"Date"},mt:"prm",nm:"start"}]],nm:"periodFrom"}},$at:{hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:11,mt:"g",an:[{doc:["Implementation compatible with [[equals]] method.\n\nThis implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]}],nm:"hash"}},nm:"Date"},DateTime:{pa:1,mt:"i",an:[{doc:["An abstract moment in time (like _4pm, October 21. 2012_).\n\nDateTime does not contain a time zone information, so You can not use it to record or \nschedule events."]}],sts:[{pk:"ceylon.time.base",nm:"ReadableDateTime"},{ta:{"DateTimeBehavior.DateType":{pk:".",nm:"Date"},"DateTimeBehavior.TimeType":{pk:".",nm:"Time"},"DateTimeBehavior.Element":{pk:".",nm:"DateTime"}},pk:"ceylon.time.base",nm:"DateTimeBehavior"},{md:"$",ta:{"Ordinal.Other":{pk:".",nm:"DateTime"}},pk:"$",nm:"Ordinal"},{md:"$",ta:{"Enumerable.Other":{pk:".",nm:"DateTime"}},pk:"$",nm:"Enumerable"},{md:"$",ta:{"Comparable.Other":{pk:".",nm:"DateTime"}},pk:"$",nm:"Comparable"}],$m:{plus:{$t:{pk:".",nm:"DateTime"},pa:5,mt:"m",an:[{doc:["Adds a specified period to this date and time."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadablePeriod"},mt:"prm",nm:"period"}]],nm:"plus"},minus:{$t:{pk:".",nm:"DateTime"},pa:5,mt:"m",an:[{doc:["Subtracts a specified period to this date and time."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadablePeriod"},mt:"prm",nm:"period"}]],nm:"minus"},rangeTo:{$t:{pk:".",nm:"DateTimeRange"},pa:5,mt:"m",an:[{doc:["Returns the [[DateTimeRange]] between this and given [[DateTime]]."]}],ps:[[{$t:{pk:".",nm:"DateTime"},mt:"prm",nm:"other"}]],nm:"rangeTo"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:11,mt:"m",an:[{doc:["Two `DateTime`s are considered equals if they represent the same \n[[Date]] and [[Time]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"},periodTo:{$t:{pk:".",nm:"Period"},pa:5,mt:"m",an:[{doc:["Returns the period between this and the given DateTime.\n\nIf this DateTime is after the given DateTime then return zero period."]}],ps:[[{$t:{pk:".",nm:"DateTime"},mt:"prm",nm:"end"}]],nm:"periodTo"},instant:{$t:{pk:".",nm:"Instant"},pa:5,mt:"m",an:[{doc:["Returns an instant from this [[DateTime]]."]}],ps:[[{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],nm:"instant"},periodFrom:{$t:{pk:".",nm:"Period"},pa:5,mt:"m",an:[{doc:["Returns the period between this and the given DateTime.\n\nIf this date is before the given date then return zero period."]}],ps:[[{$t:{pk:".",nm:"DateTime"},mt:"prm",nm:"start"}]],nm:"periodFrom"}},$at:{hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:11,mt:"g",an:[{doc:["Implementation compatible with [[equals]] method.\n\nThis implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]}],nm:"hash"}},nm:"DateTime"},Duration:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["Duration specifies a discreet amount of milliseconds between two instances of time."]}],sts:[{pk:"ceylon.time.base",nm:"ReadableDuration"},{md:"$",ta:{"Scalable.Scale":{md:"$",pk:"$",nm:"Integer"},"Scalable.Value":{pk:".",nm:"Duration"}},pk:"$",nm:"Scalable"}],$m:{scale:{$t:{pk:".",nm:"Duration"},pa:3,mt:"m",an:[{doc:["Returns a new [[Duration]] with it´s milliseconds scaled."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"scale"}]],nm:"scale"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",an:[{doc:["Duration is considered equal when type and milliseconds are the same."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"}},$at:{hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]}],nm:"hash"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:[{doc:["Returns the string representation of this duration."]}],nm:"string"},period:{$t:{pk:".",nm:"Period"},pa:1,mt:"g",an:[{doc:["Returns this duration as a period of milliseconds."]}],nm:"period"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{doc:["Number of milliseconds of this duration."]}],nm:"milliseconds"}},ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"prm",an:[{doc:["Number of milliseconds of this duration."]}],$hdn:1,nm:"milliseconds"}],nm:"Duration"},"$pkg-pa":1,DateRange:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["Implementation of [[Range]] and allows easy iteration between [[Date]] types.\n\nProvides all power of [[Iterable]] features and complements with:\n* Easy way to recover [[Period]]\n* Easy way to recover [[Duration]]\n* Recover the overlap between [[DateRange]] types\n* Recover the gap between [[DateRange]] types\n* Allows customized way to iterate as navigate between values by [[UnitOfDate]] cases\n"]},{see:["Range"]}],sts:[{ta:{"Range.Element":{pk:".",nm:"Date"},"Range.StepBy":{pk:"ceylon.time.base",nm:"UnitOfDate"}},pk:"ceylon.time.base",nm:"Range"}],$m:{iterator:{$t:{md:"$",ta:{"Iterator.Element":{pk:".",nm:"Date"}},pk:"$",nm:"Iterator"},pa:3,mt:"m",an:[{doc:["An iterator for the elements belonging to this \ncontainer. where each jump is based on actual step of this Range."]}],$o:{listIterator$bgdwol:{super:{md:"$",pk:"$",nm:"Basic"},mt:"o",sts:[{md:"$",ta:{"Iterator.Element":{pk:".",nm:"Date"}},pk:"$",nm:"Iterator"}],$m:{next:{$t:{comp:"u",l:[{pk:".",nm:"Date"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},$at:{count$1fh4vb:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"count"}},nm:"listIterator"}},nm:"iterator"},overlap:{$t:{comp:"u",l:[{pk:".",nm:"DateRange"},{md:"$",pk:"$",nm:"Empty"}]},pa:3,mt:"m",an:[{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A] \n- The precision is based on the lowest unit \n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB < CD\n\n    [1..6] overlap [3..9] = [3,6]\n\n    [1..6] overlap [9..3] = [3,6]\n\n    [6..1] overlap [3..9] = [3,6]\n\n    [6..1] overlap [9..3] = [3,6]\n\n\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB > CD\n\n    [3..9] overlap [1..6] = [3,6]\n\n    [3..9] overlap [6..1] = [3,6]\n\n    [9..3] overlap [1..6] = [3,6]\n\n    [9..3] overlap [6..1] = [3,6]"]}],ps:[[{$t:{ta:{"Range.Element":{pk:".",nm:"Date"},"Range.StepBy":{pk:"ceylon.time.base",nm:"UnitOfDate"}},pk:"ceylon.time.base",nm:"Range"},mt:"prm",nm:"other"}]],nm:"overlap"},nextByStep$x6l2vu:{$t:{pk:".",nm:"Date"},mt:"m",an:[{doc:["The iteration for each element should always start from same point,\nthis way is possible to not suffer with different number of days in months."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"jump"}]],nm:"nextByStep"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",an:[{doc:["Returns true if both: this and other are same type and have equal fields _from_ and _to_."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"},previousByStep$lx41mm:{$t:{pk:".",nm:"Date"},mt:"m",an:[{doc:["The iteration for each element should always start from same point,\nthis way is possible to not suffer with different number of days in months."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"jump"}]],nm:"previousByStep"},stepBy:{$t:{pk:".",nm:"DateRange"},pa:3,mt:"m",an:[{doc:["Define how this Range will get next or previous element while iterating."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"UnitOfDate"},mt:"prm",nm:"step"}]],nm:"stepBy"},gap:{$t:{comp:"u",l:[{pk:".",nm:"DateRange"},{md:"$",pk:"$",nm:"Empty"}]},pa:3,mt:"m",an:[{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A] \n- The precision is based on the lowest unit \n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB < CD\n\n    [1..2] gap [5..6] = (2,5)\n\n    [1..2] gap [6..5] = (2,5)\n\n    [2..1] gap [5..6] = (2,5)\n\n    [2..1] gap [6..5] = (2,5)\n\n\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB > CD\n\n    [5..6] gap [1..2] = (2,5)\n\n    [5..6] gap [2..1] = (2,5)\n\n    [6..5] gap [1..2] = (2,5)\n\n    [6..5] gap [2..1] = (2,5)"]}],ps:[[{$t:{ta:{"Range.Element":{pk:".",nm:"Date"},"Range.StepBy":{pk:"ceylon.time.base",nm:"UnitOfDate"}},pk:"ceylon.time.base",nm:"Range"},mt:"prm",nm:"other"}]],nm:"gap"}},$at:{to:{$t:{pk:".",nm:"Date"},pa:3,mt:"a",an:[{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]}],nm:"to"},duration:{$t:{pk:".",nm:"Duration"},pa:3,mt:"g",an:[{doc:["Returns the Duration between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 86400000 milliseconds.\n\nGiven: tomorrow().to(today).duration then duration is -86400000 milliseconds."]}],nm:"duration"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]}],nm:"hash"},from:{$t:{pk:".",nm:"Date"},pa:3,mt:"a",an:[{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]}],nm:"from"},period:{$t:{pk:".",nm:"Period"},pa:3,mt:"g",an:[{doc:["Returns the Period between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 1 day.\n\nGiven: tomorrow().to(today).duration then duration is -1 day."]}],nm:"period"},step:{$t:{pk:"ceylon.time.base",nm:"UnitOfDate"},pa:3,mt:"a",an:[{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]}],nm:"step"}},ps:[{$t:{pk:".",nm:"Date"},pa:3,mt:"prm",an:[{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]}],$hdn:1,nm:"from"},{$t:{pk:".",nm:"Date"},pa:3,mt:"prm",an:[{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]}],$hdn:1,nm:"to"},{$t:{pk:"ceylon.time.base",nm:"UnitOfDate"},def:1,pa:3,mt:"prm",an:[{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]}],$hdn:1,nm:"step"}],nm:"DateRange"},Instant:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["A specific instant of time on a continuous time-scale.\n\nAn instant represents a single point in time irrespective of \nany time-zone offsets or geographical locations."]}],sts:[{pk:"ceylon.time.base",nm:"ReadableInstant"},{md:"$",ta:{"Comparable.Other":{pk:".",nm:"Instant"}},pk:"$",nm:"Comparable"},{md:"$",ta:{"Enumerable.Other":{pk:".",nm:"Instant"}},pk:"$",nm:"Enumerable"}],$m:{durationFrom:{$t:{pk:".",nm:"Duration"},pa:1,mt:"m",an:[{doc:["Returns duration in milliseconds from other instant to this instant."]}],ps:[[{$t:{pk:".",nm:"Instant"},mt:"prm",nm:"other"}]],nm:"durationFrom"},plus:{$t:{pk:".",nm:"Instant"},pa:1,mt:"m",an:[{doc:["Adds a period to this instant."]}],ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Duration"},{pk:".",nm:"Period"}]},mt:"prm",nm:"other"}]],nm:"plus"},durationTo:{$t:{pk:".",nm:"Duration"},pa:1,mt:"m",an:[{doc:["Returns duration in milliseconds from this instant to the other instant."]}],ps:[[{$t:{pk:".",nm:"Instant"},mt:"prm",nm:"other"}]],nm:"durationTo"},time:{$t:{pk:".",nm:"Time"},pa:1,mt:"m",an:[{doc:["Returns _time of day_ for this instant."]}],ps:[[{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],nm:"time"},minus:{$t:{pk:".",nm:"Instant"},pa:1,mt:"m",an:[{doc:["Subtracts a period to this instant."]}],ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Duration"},{pk:".",nm:"Period"}]},mt:"prm",nm:"other"}]],nm:"minus"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",an:[{doc:["Returns _true_ if given value is same type and milliseconds of epoch."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"},dateTime:{$t:{pk:".",nm:"DateTime"},pa:1,mt:"m",an:[{doc:["Returns this instant as a [[DateTime]] value."]}],ps:[[{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],nm:"dateTime"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,mt:"m",an:[{doc:["Compares this instant to the _other_ instant."]}],ps:[[{$t:{pk:".",nm:"Instant"},mt:"prm",nm:"other"}]],nm:"compare"},zoneDateTime:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:1,mt:"m",an:[{doc:["Returns ZoneDateTime value for this instant."]}],ps:[[{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],nm:"zoneDateTime"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Instant"},mt:"prm",nm:"other"}]],nm:"offset"},neighbour:{$t:{pk:".",nm:"Instant"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"neighbour"},date:{$t:{pk:".",nm:"Date"},pa:1,mt:"m",an:[{doc:["Returns this instant as a [[Date]] value."]}],ps:[[{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],nm:"date"}},$at:{hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]}],nm:"hash"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:[{doc:["Returns ISO-8601 formatted String representation of this _time of day_ in UTC.\n\nReference: [ISO-8601 Time Offsets from UTC](https:\/\/en.wikipedia.org\/wiki\/ISO_8601#Time_offsets_from_UTC)"]}],nm:"string"},millisecondsOfEpoch:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{doc:["Internal value of an instant as a number of milliseconds since\n1970-01-01T00:00:00.000Z."]}],nm:"millisecondsOfEpoch"}},ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"prm",an:[{doc:["Internal value of an instant as a number of milliseconds since\n1970-01-01T00:00:00.000Z."]}],$hdn:1,nm:"millisecondsOfEpoch"}],nm:"Instant"},YearMonth:{pa:1,mt:"i",an:[{doc:["An interface for year and month objects representation in the ISO-8601 calendar system.\n\nA YearMonth is often viewed as pair of year-month values. \n"]}],sts:[{pk:"ceylon.time.base",nm:"ReadableYear"},{pk:"ceylon.time.base",nm:"ReadableMonth"},{ta:{"YearBehavior.Element":{pk:".",nm:"YearMonth"}},pk:"ceylon.time.base",nm:"YearBehavior"},{ta:{"MonthBehavior.Element":{pk:".",nm:"YearMonth"}},pk:"ceylon.time.base",nm:"MonthBehavior"},{md:"$",ta:{"Ordinal.Other":{pk:".",nm:"YearMonth"}},pk:"$",nm:"Ordinal"},{md:"$",ta:{"Comparable.Other":{pk:".",nm:"YearMonth"}},pk:"$",nm:"Comparable"},{md:"$",ta:{"Enumerable.Other":{pk:".",nm:"YearMonth"}},pk:"$",nm:"Enumerable"}],$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"}},$at:{hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"hash"}},nm:"YearMonth"},FixedMilliseconds:{super:{md:"$",pk:"$",nm:"Basic"},mt:"c",an:[{doc:["Implementation of a clock that always returns the same instant.\n\nThis is typically used for testing."]}],sts:[{pk:".",nm:"Clock"}],$m:{instant:{$t:{pk:".",nm:"Instant"},pa:3,mt:"m",an:[{doc:["Returns the instant from the fixed milliseconds."]}],nm:"instant"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",an:[{doc:["Returns the fixed milliseconds."]}],nm:"milliseconds"}},$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",an:[{doc:["Returns the fixed [[Instant]] that this [[Clock]] represents."]}],nm:"string"},fixedMilliseconds$ip85yf:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"a",nm:"fixedMilliseconds"}},ps:[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"fixedMilliseconds"}],nm:"FixedMilliseconds"},offsetTime:{$t:{pk:".",nm:"Clock"},pa:1,mt:"m",an:[{doc:["Returns an implementation of a clock that always returns a \nconstant offset from the value of the provided clock."]}],ps:[[{$t:{pk:".",nm:"Clock"},mt:"prm",nm:"baseClock"},{$t:{pk:".",nm:"Duration"},mt:"prm",nm:"offset"}]],nm:"offsetTime"},fixedTime:{$t:{pk:".",nm:"Clock"},pa:1,mt:"m",an:[{doc:["Gets a clock that always returns the same instant in the UTC time-zone."]}],ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Instant"},{md:"$",pk:"$",nm:"Integer"}]},mt:"prm",nm:"instant"}]],nm:"fixedTime"},TimeRange:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["Implementation of [[Range]] and allows easy iteration between [[Time]] types.\n\nProvides all power of [[Iterable]] features and complements with:\n* Easy way to recover [[Period]]\n* Easy way to recover [[Duration]]\n* Recover the overlap between [[TimeRange]] types\n* Recover the gap between [[TimeRange]] types\n* Allows customized way to iterate as navigate between values by [[UnitOfTime]] cases\n"]},{see:["Range"]}],sts:[{ta:{"Range.Element":{pk:".",nm:"Time"},"Range.StepBy":{pk:"ceylon.time.base",nm:"UnitOfTime"}},pk:"ceylon.time.base",nm:"Range"}],$m:{iterator:{$t:{md:"$",ta:{"Iterator.Element":{pk:".",nm:"Time"}},pk:"$",nm:"Iterator"},pa:3,mt:"m",an:[{doc:["An iterator for the elements belonging to this \ncontainer. where each jump is based on actual step of this Range."]}],$o:{listIterator$itbwha:{super:{md:"$",pk:"$",nm:"Basic"},mt:"o",sts:[{md:"$",ta:{"Iterator.Element":{pk:".",nm:"Time"}},pk:"$",nm:"Iterator"}],$m:{next:{$t:{comp:"u",l:[{pk:".",nm:"Time"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},$at:{count$dw3q34:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"count"}},nm:"listIterator"}},nm:"iterator"},nextByStep$9cla77:{$t:{pk:".",nm:"Time"},mt:"m",an:[{doc:["The iteration for each element should always start from same point."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"jump"}]],nm:"nextByStep"},overlap:{$t:{comp:"u",l:[{pk:".",nm:"TimeRange"},{md:"$",pk:"$",nm:"Empty"}]},pa:3,mt:"m",an:[{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A]\n- The precision is based on the lowest unit \n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB < CD\n\n    [1..6] overlap [3..9] = [3,6]\n\n    [1..6] overlap [9..3] = [3,6]\n\n    [6..1] overlap [3..9] = [3,6]\n\n    [6..1] overlap [9..3] = [3,6]\n\n\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB > CD\n\n    [3..9] overlap [1..6] = [3,6]\n\n    [3..9] overlap [6..1] = [3,6]\n\n    [9..3] overlap [1..6] = [3,6]\n\n    [9..3] overlap [6..1] = [3,6]"]}],ps:[[{$t:{ta:{"Range.Element":{pk:".",nm:"Time"},"Range.StepBy":{pk:"ceylon.time.base",nm:"UnitOfTime"}},pk:"ceylon.time.base",nm:"Range"},mt:"prm",nm:"other"}]],nm:"overlap"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",an:[{doc:["Returns true if both: this and other are same type and have equal fields _from_ and _to_."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"},stepBy:{$t:{pk:".",nm:"TimeRange"},pa:3,mt:"m",an:[{doc:["Define how this Range will get next or previous element while iterating."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"UnitOfTime"},mt:"prm",nm:"step"}]],nm:"stepBy"},previousByStep$1wvr21:{$t:{pk:".",nm:"Time"},mt:"m",an:[{doc:["The iteration for each element should always start from same point."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"jump"}]],nm:"previousByStep"},gap:{$t:{comp:"u",l:[{pk:".",nm:"TimeRange"},{md:"$",pk:"$",nm:"Empty"}]},pa:3,mt:"m",an:[{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A]\n- The precision is based on the lowest unit\n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] gap [C..D]\n\nWhen: AB < CD\n\n    [1..2] gap [5..6] = (2,5)\n\n    [1..2] gap [6..5] = (2,5)\n\n    [2..1] gap [5..6] = (2,5)\n\n    [2..1] gap [6..5] = (2,5)\n\n\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB > CD\n\n    [5..6] gap [1..2] = (2,5)\n\n    [5..6] gap [2..1] = (2,5)\n\n    [6..5] gap [1..2] = (2,5)\n\n    [6..5] gap [2..1] = (2,5)"]}],ps:[[{$t:{ta:{"Range.Element":{pk:".",nm:"Time"},"Range.StepBy":{pk:"ceylon.time.base",nm:"UnitOfTime"}},pk:"ceylon.time.base",nm:"Range"},mt:"prm",nm:"other"}]],nm:"gap"}},$at:{to:{$t:{pk:".",nm:"Time"},pa:3,mt:"a",an:[{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]}],nm:"to"},duration:{$t:{pk:".",nm:"Duration"},pa:3,mt:"g",an:[{doc:["Returns the Duration between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 86400000 milliseconds.\n\nGiven: tomorrow().to(today).duration then duration is -86400000 milliseconds."]}],nm:"duration"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]}],nm:"hash"},from:{$t:{pk:".",nm:"Time"},pa:3,mt:"a",an:[{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]}],nm:"from"},period:{$t:{pk:".",nm:"Period"},pa:3,mt:"g",an:[{doc:["Returns the Period between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 1 day.\n\nGiven: tomorrow().to(today).duration then duration is -1 day."]}],nm:"period"},step:{$t:{pk:"ceylon.time.base",nm:"UnitOfTime"},pa:3,mt:"a",an:[{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]}],nm:"step"}},ps:[{$t:{pk:".",nm:"Time"},pa:3,mt:"prm",an:[{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]}],$hdn:1,nm:"from"},{$t:{pk:".",nm:"Time"},pa:3,mt:"prm",an:[{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]}],$hdn:1,nm:"to"},{$t:{pk:"ceylon.time.base",nm:"UnitOfTime"},def:1,pa:3,mt:"prm",an:[{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]}],$hdn:1,nm:"step"}],nm:"TimeRange"},yearMonth:{$t:{pk:".",nm:"YearMonth"},pa:1,mt:"m",an:[{doc:["Returns a year and month representation based on the specified values."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:"ceylon.time.base",nm:"Month"}]},mt:"prm",nm:"month"}]],nm:"yearMonth"},now:{$t:{pk:".",nm:"Instant"},pa:1,mt:"m",an:[{doc:["Obtains the current instant from the system clock."]}],ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Clock"}]},def:1,mt:"prm",nm:"clock"}]],nm:"now"},DateTimeRange:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["Implementation of [[Range]] and allows easy iteration between [[DateTime]] types.\n\nProvides all power of [[Iterable]] features and complements with:\n* Easy way to recover [[Period]]\n* Easy way to recover [[Duration]]\n* Recover the overlap between [[DateTimeRange]] types\n* Recover the gap between [[DateTimeRange]] types\n* Allows customized way to iterate as navigate between values by [[UnitOfDate]] or [[UnitOfTime]] cases\n"]}],sts:[{ta:{"Range.Element":{pk:".",nm:"DateTime"},"Range.StepBy":{comp:"u",l:[{pk:"ceylon.time.base",nm:"UnitOfDate"},{pk:"ceylon.time.base",nm:"UnitOfTime"}]}},pk:"ceylon.time.base",nm:"Range"}],$m:{nextByStep$cusa3f:{$t:{pk:".",nm:"DateTime"},mt:"m",an:[{doc:["The iteration for each element should always start from same point,\nthis way is possible to not suffer with different number of days in months."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"jump"}]],nm:"nextByStep"},iterator:{$t:{md:"$",ta:{"Iterator.Element":{pk:".",nm:"DateTime"}},pk:"$",nm:"Iterator"},pa:3,mt:"m",an:[{doc:["An iterator for the elements belonging to this \ncontainer. where each jump is based on actual step of this Range."]}],$o:{listIterator$tg8jkg:{super:{md:"$",pk:"$",nm:"Basic"},mt:"o",sts:[{md:"$",ta:{"Iterator.Element":{pk:".",nm:"DateTime"}},pk:"$",nm:"Iterator"}],$m:{next:{$t:{comp:"u",l:[{pk:".",nm:"DateTime"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},$at:{count$xwt382:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"count"}},nm:"listIterator"}},nm:"iterator"},overlap:{$t:{comp:"u",l:[{pk:".",nm:"DateTimeRange"},{md:"$",pk:"$",nm:"Empty"}]},pa:3,mt:"m",an:[{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A] \n- The precision is based on the lowest unit \n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB < CD\n\n    [1..6] overlap [3..9] = [3,6]\n\n    [1..6] overlap [9..3] = [3,6]\n\n    [6..1] overlap [3..9] = [3,6]\n\n    [6..1] overlap [9..3] = [3,6]\n\n\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB > CD\n\n    [3..9] overlap [1..6] = [3,6]\n\n    [3..9] overlap [6..1] = [3,6]\n\n    [9..3] overlap [1..6] = [3,6]\n\n    [9..3] overlap [6..1] = [3,6]"]}],ps:[[{$t:{ta:{"Range.Element":{pk:".",nm:"DateTime"},"Range.StepBy":{comp:"u",l:[{pk:"ceylon.time.base",nm:"UnitOfDate"},{pk:"ceylon.time.base",nm:"UnitOfTime"}]}},pk:"ceylon.time.base",nm:"Range"},mt:"prm",nm:"other"}]],nm:"overlap"},previousByStep$o49bcn:{$t:{pk:".",nm:"DateTime"},mt:"m",an:[{doc:["The iteration for each element should always start from same point,\nthis way is possible to not suffer with different number of days in months."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"jump"}]],nm:"previousByStep"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",an:[{doc:["Returns true if both: this and other are same type and have equal fields _from_ and _to_."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"},stepBy:{$t:{pk:".",nm:"DateTimeRange"},pa:3,mt:"m",an:[{doc:["Define how this Range will get next or previous element while iterating."]}],ps:[[{$t:{comp:"u",l:[{pk:"ceylon.time.base",nm:"UnitOfDate"},{pk:"ceylon.time.base",nm:"UnitOfTime"}]},mt:"prm",nm:"step"}]],nm:"stepBy"},gap:{$t:{comp:"u",l:[{pk:".",nm:"DateTimeRange"},{md:"$",pk:"$",nm:"Empty"}]},pa:3,mt:"m",an:[{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A] \n- The precision is based on the lowest unit \n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB < CD\n\n    [1..2] gap [5..6] = (2,5)\n\n    [1..2] gap [6..5] = (2,5)\n\n    [2..1] gap [5..6] = (2,5)\n\n    [2..1] gap [6..5] = (2,5)\n\n\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB > CD\n\n    [5..6] gap [1..2] = (2,5)\n\n    [5..6] gap [2..1] = (2,5)\n\n    [6..5] gap [1..2] = (2,5)\n\n    [6..5] gap [2..1] = (2,5)"]}],ps:[[{$t:{ta:{"Range.Element":{pk:".",nm:"DateTime"},"Range.StepBy":{comp:"u",l:[{pk:"ceylon.time.base",nm:"UnitOfDate"},{pk:"ceylon.time.base",nm:"UnitOfTime"}]}},pk:"ceylon.time.base",nm:"Range"},mt:"prm",nm:"other"}]],nm:"gap"}},$at:{to:{$t:{pk:".",nm:"DateTime"},pa:3,mt:"a",an:[{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]}],nm:"to"},duration:{$t:{pk:".",nm:"Duration"},pa:3,mt:"g",an:[{doc:["Returns the Duration between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 86400000 milliseconds.\n\nGiven: tomorrow().to(today).duration then duration is -86400000 milliseconds."]}],nm:"duration"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]}],nm:"hash"},from:{$t:{pk:".",nm:"DateTime"},pa:3,mt:"a",an:[{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]}],nm:"from"},period:{$t:{pk:".",nm:"Period"},pa:3,mt:"g",an:[{doc:["Returns the Period between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 1 day.\n\nGiven: tomorrow().to(today).duration then duration is -1 day."]}],nm:"period"},step:{$t:{comp:"u",l:[{pk:"ceylon.time.base",nm:"UnitOfDate"},{pk:"ceylon.time.base",nm:"UnitOfTime"}]},pa:3,mt:"a",an:[{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]}],nm:"step"}},ps:[{$t:{pk:".",nm:"DateTime"},pa:3,mt:"prm",an:[{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]}],$hdn:1,nm:"from"},{$t:{pk:".",nm:"DateTime"},pa:3,mt:"prm",an:[{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]}],$hdn:1,nm:"to"},{$t:{comp:"u",l:[{pk:"ceylon.time.base",nm:"UnitOfDate"},{pk:"ceylon.time.base",nm:"UnitOfTime"}]},def:1,pa:3,mt:"prm",an:[{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]}],$hdn:1,nm:"step"}],nm:"DateTimeRange"},FixedInstant:{super:{md:"$",pk:"$",nm:"Basic"},mt:"c",an:[{doc:["Implementation of a clock that always returns the same instant.\n\nThis is typically used for testing."]}],sts:[{pk:".",nm:"Clock"}],$m:{instant:{$t:{pk:".",nm:"Instant"},pa:3,mt:"m",an:[{doc:["Returns the fixed instant."]}],nm:"instant"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",an:[{doc:["Returns milliseconds from the fixed instant."]}],nm:"milliseconds"}},$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",an:[{doc:["Returns the fixed [[Instant]] that this [[Clock]] represents."]}],nm:"string"},fixedInstant$dw5xdz:{$t:{pk:".",nm:"Instant"},mt:"a",nm:"fixedInstant"}},ps:[{$t:{pk:".",nm:"Instant"},mt:"prm",nm:"fixedInstant"}],nm:"FixedInstant"},OffsetClock:{super:{md:"$",pk:"$",nm:"Basic"},mt:"c",an:[{doc:["An implementation of a [[Clock]] that returns time with a constant \noffset from the provided clock."]}],sts:[{pk:".",nm:"Clock"}],$m:{instant:{$t:{pk:".",nm:"Instant"},pa:3,mt:"m",nm:"instant"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",nm:"milliseconds"}},$at:{baseClock$wp0y7f:{$t:{pk:".",nm:"Clock"},mt:"a",nm:"baseClock"},offset$fimsw5:{$t:{pk:".",nm:"Duration"},mt:"a",nm:"offset"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",an:[{doc:["Returns the [[offsetTime]] period from given [[Clock]]."]}],nm:"string"}},ps:[{$t:{pk:".",nm:"Clock"},mt:"prm",nm:"baseClock"},{$t:{pk:".",nm:"Duration"},mt:"prm",nm:"offset"}],nm:"OffsetClock"},"$pkg-anns":[{doc:["Main package for the Ceylon's Date and Time library.\n\nLike in [JodaTime] and [JSR-310], there is a _machine timeline_ and a _human timeline_.\n\n[JodaTime]: http:\/\/joda-time.sourceforge.net\n[JSR-310]: http:\/\/sourceforge.net\/apps\/mediawiki\/threeten\/index.php?title=ThreeTen\n\n## Machine timeline\n\nMachine timeline is represented by an [[Instant]] that is basically just an object\nwrapper around an [[Integer]] representing _[Unix time]_ value. A value of an Instant\nuniquely identifies a particular instant of time without needing to take into account\ntimezone information and contain no ambiguities associated with [DST] changeover times.\n\n[Unix time]: http:\/\/en.wikipedia.org\/wiki\/Unix_time\n[DST]: http:\/\/en.wikipedia.org\/wiki\/Daylight_saving_time\n\n## Human timeline\n\nHuman timeline is based mostly on Gregorian and ISO-8601 calendar systems and consists of\nthe following principal data types:\n\n* [[Date]] -- A date value without time component.\n* [[Time]] -- A time of day vallue without date component.\n* [[DateTime]] -- A particular time of a particular date.\n* [[ceylon.time.timezone::ZoneDateTime]] -- A particular moment of time identified by date, time of day and\n  a time zone.\n\n**Note:** At the moment, timezone is not fully supported, therefore current\nconversions can uses offsets provided by VMs  and provides some features like [[ceylon.time.timezone::timeZone]]\nobject that allows parser and creation of fixed offsets.\n"]},{by:["Diego Coronel","Roland Tepp"]}]},"ceylon.time.timezone.parser.iana":{ZoneName:{pa:1,mt:"als",$alias:{md:"$",pk:"$",nm:"String"},nm:"ZoneName"},parseOnDay:{$t:{pk:"ceylon.time.timezone.model",nm:"OnDay"},pa:1,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"token"}]],nm:"parseOnDay"},parseLinkLine:{$t:{pk:"ceylon.time.timezone.model",nm:"Link"},pa:1,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"line"}]],nm:"parseLinkLine"},Signal:{pa:1,mt:"als",an:[{doc:["Alias to represent a specific signal:\n* Positive = 1\n* Negative = -1"]}],$alias:{md:"$",pk:"$",nm:"Integer"},nm:"Signal"},parseOnDayToken:{$t:{l:[{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time.timezone.model",nm:"DayOfMonth"}]},{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time.base",nm:"DayOfWeek"}]},{md:"$",pk:"$",nm:"Comparison"}],pk:"$",nm:"Tuple"},mt:"m",$m:{parseInteger$bzuxq8:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Null"}]},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"parseInteger"}},ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"token"}]],nm:"parseOnDayToken"},toPeriod:{$t:{pk:"ceylon.time",nm:"Period"},mt:"m",an:[{doc:["Transform time in Period \n\nP.S.: This is a good case to add this feature to Time. something like:\n      time(1,0).period"]}],ps:[[{$t:{l:[{pk:"ceylon.time.timezone.model",nm:"AtTime"},{pk:".",nm:"Signal"}],pk:"$",nm:"Tuple"},mt:"prm",nm:"signedTime"}]],nm:"toPeriod"},RuleName:{pa:1,mt:"als",an:[{doc:["Parse current token using http:\/\/www.cstdbill.com\/tzdb\/tz-how-to.html \ncolumns as reference"]}],$alias:{md:"$",pk:"$",nm:"String"},nm:"RuleName"},findDayOfWeek:{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"dayOfWeek"}]],nm:"findDayOfWeek"},tokenDelimiter:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"char"}]],nm:"tokenDelimiter"},parseMonth:{$t:{pk:"ceylon.time.base",nm:"Month"},pa:1,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"month"}]],nm:"parseMonth"},parseZoneFormat:{$t:{pk:"ceylon.time.timezone.model",nm:"ZoneFormat"},pa:1,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"token"}]],nm:"parseZoneFormat"},parseZoneRule:{$t:{pk:"ceylon.time.timezone.model",nm:"ZoneRule"},pa:1,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"token"}]],nm:"parseZoneRule"},parseZoneLine:{$t:{l:[{pk:".",nm:"ZoneName"},{pk:"ceylon.time.timezone.model",nm:"ZoneTimeline"}],pk:"$",nm:"Tuple"},pa:1,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"line"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"ZoneName"}]},def:1,mt:"prm",nm:"zoneName"}]],nm:"parseZoneLine"},atTimeDefinition:{$t:{pk:"ceylon.time.timezone.model",nm:"AtTime"},mt:"m",ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"},{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"token"}]],nm:"atTimeDefinition"},parseUntil:{$t:{pk:"ceylon.time.timezone.model",nm:"ZoneUntil"},pa:1,mt:"m",ps:[[{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"String"}},pk:"$",nm:"Sequential"},mt:"prm",nm:"token"}]],nm:"parseUntil"},parseTime:{$t:{l:[{pk:"ceylon.time.timezone.model",nm:"AtTime"},{pk:".",nm:"Signal"}],pk:"$",nm:"Tuple"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"atTime"}]],nm:"parseTime"},adjustToEndOfDayIfNecessary:{$t:{pk:"ceylon.time",nm:"Time"},mt:"m",an:[{doc:["The rules represent the end of day as 24:00 and our ceylon.time.Time \ndoes have another semantic for this."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"adjustToEndOfDayIfNecessary"},parseRuleLine:{$t:{l:[{pk:".",nm:"RuleName"},{pk:"ceylon.time.timezone.model",nm:"Rule"}],pk:"$",nm:"Tuple"},pa:1,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"line"}]],nm:"parseRuleLine"},parseYear:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"year"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"defaultYear"}]],nm:"parseYear"},"$pkg-pa":1,"$pkg-anns":[{by:["Diego Coronel","Roland Tepp"]}]},"ceylon.time.timezone":{OffsetTimeZone:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["A simple time zone with a constant offset from UTC."]}],sts:[{pk:".",nm:"TimeZone"}],$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",an:[{doc:["Returns _true_ if given value is same type and offset milliseconds."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",an:[{doc:["Returns offset in milliseconds of the specified instant according to this time zone.\n\nThis implementation always returns a constant offset."]}],ps:[[{$t:{pk:"ceylon.time",nm:"Instant"},mt:"prm",nm:"instant"}]],nm:"offset"}},$at:{hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]}],nm:"hash"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:11,mt:"g",an:[{doc:["Returns ISO-8601 formatted String representation of this _time of day_.\n\nhttps:\/\/en.wikipedia.org\/wiki\/ISO_8601#Time_offsets_from_UTC"]}],nm:"string"},offsetMilliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["The value that represents this constant offset in milliseconds."]}],nm:"offsetMilliseconds"}},ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"prm",an:[{doc:["The value that represents this constant offset in milliseconds."]}],$hdn:1,nm:"offsetMilliseconds"}],nm:"OffsetTimeZone"},ReadableTimeZone:{pa:1,mt:"i",an:[{doc:["Common interface that can hold a reference to a specific time zone."]}],$at:{timeZone:{$t:{pk:".",nm:"TimeZone"},pa:5,mt:"a",an:[{doc:["Time zone value."]}],nm:"timeZone"}},nm:"ReadableTimeZone"},ZoneDateTime:{pa:1,mt:"i",an:[{doc:["Instant of time in a specific time zone."]}],sts:[{pk:".",nm:"ReadableZoneDateTime"},{pk:"ceylon.time.base",nm:"ReadableDateTime"},{pk:".",nm:"ReadableTimeZone"},{ta:{"DateTimeBehavior.DateType":{pk:"ceylon.time",nm:"Date"},"DateTimeBehavior.TimeType":{pk:"ceylon.time",nm:"Time"},"DateTimeBehavior.Element":{pk:".",nm:"ZoneDateTime"}},pk:"ceylon.time.base",nm:"DateTimeBehavior"},{md:"$",ta:{"Comparable.Other":{pk:".",nm:"ZoneDateTime"}},pk:"$",nm:"Comparable"},{md:"$",ta:{"Ordinal.Other":{pk:".",nm:"ZoneDateTime"}},pk:"$",nm:"Ordinal"},{md:"$",ta:{"Enumerable.Other":{pk:".",nm:"ZoneDateTime"}},pk:"$",nm:"Enumerable"}],$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",an:[{doc:["Returns _true_ if given value is same date, time and timezone."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"}},$at:{hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:11,mt:"g",an:[{doc:["Implementation compatible with [[equals]] method.\n\nThis implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]}],nm:"hash"},dateTime:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:5,mt:"a",an:[{doc:["Local date and time according to the current time zone of this instance.\n\n**Note:** The resulting [[DateTime]], is a local representation of \nthis date and time stripped of any time zone information."]}],nm:"dateTime"},currentOffsetMilliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:9,mt:"g",an:[{doc:["Returns current time zone offset from UTC in milliseconds"]}],nm:"currentOffsetMilliseconds"},instant:{$t:{pk:"ceylon.time",nm:"Instant"},pa:5,mt:"a",an:[{doc:["Instant used as base."]}],nm:"instant"}},nm:"ZoneDateTime"},zoneDateTime:{$t:{pk:".",nm:"ZoneDateTime"},pa:1,mt:"m",an:[{doc:["Returns a [[ZoneDateTime]] based on the specified [[TimeZone]], year, month, day of month, hour, minute, second and millisecond values."]}],ps:[[{$t:{pk:".",nm:"TimeZone"},mt:"prm",nm:"timeZone"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:"ceylon.time.base",nm:"Month"}]},mt:"prm",nm:"month"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"date"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"hour"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"minutes"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"seconds"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"millis"}]],nm:"zoneDateTime"},timeZone:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"o",an:[{doc:["Common utility methods for getting time zone instances."]}],$m:{offset:{$t:{pk:".",nm:"OffsetTimeZone"},pa:1,mt:"m",an:[{doc:["Represents fixed timeZone created based on given values."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"minutes"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"milliseconds"}]],nm:"offset"},parse:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"TimeZone"}]},pa:1,mt:"m",an:[{doc:["Parses input string and returns appropriate time zone.\nCurrently it accepts only ISO-8601 time zone offset patterns:\n&plusmn;`[hh]:[mm]`, &plusmn;`[hh][mm]`, and &plusmn;`[hh]`.\n\nIn addition, the special code `Z` is recognized as a shorthand for `+00:00`."]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"zone"}]],nm:"parse"}},$o:{system:{super:{pk:".",nm:"OffsetTimeZone"},pa:1,mt:"o",an:[{doc:["Current system time zone."]}],nm:"system"},utc:{super:{pk:".",nm:"OffsetTimeZone"},pa:1,mt:"o",an:[{doc:["Coordinated Universal Time (UTC) time zone."]}],$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",an:[{doc:["Returns ISO-8601 formatted String representation of this _time of day_.\n\nhttps:\/\/en.wikipedia.org\/wiki\/ISO_8601#Time_offsets_from_UTC"]}],nm:"string"}},nm:"utc"}},nm:"timeZone"},TimeZone:{of:[{pk:".",nm:"OffsetTimeZone"},{pk:".",nm:"RuleBasedTimezone"}],pa:1,mt:"i",an:[{doc:["The interface representing a timezone."]}],$m:{offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",an:[{doc:["Returns offset in milliseconds of the specified instant according to this time zone."]}],ps:[[{$t:{pk:"ceylon.time",nm:"Instant"},mt:"prm",nm:"instant"}]],nm:"offset"}},nm:"TimeZone"},ReadableZoneDateTime:{pa:1,mt:"i",an:[{doc:["Common interface that can represent particular time of day on a specific date in a specific time zone."]}],sts:[{pk:"ceylon.time.base",nm:"ReadableDate"},{pk:"ceylon.time.base",nm:"ReadableTime"},{pk:".",nm:"ReadableTimeZone"}],nm:"ReadableZoneDateTime"},RuleBasedTimezone:{pa:1,mt:"i",an:[{doc:["This represents offsets based on daylight saving time."]}],sts:[{pk:".",nm:"TimeZone"}],nm:"RuleBasedTimezone"},"$pkg-anns":[{by:["Diego Coronel","Roland Tepp"]}],"$pkg-pa":1},"ceylon.time.timezone.model":{OnFirstOfMonth:{super:{pk:".",nm:"OnDay"},pa:1,mt:"c",an:[{doc:["Represents a day equal to or higher than a day of week.\n\nFor example, given the rule `Sun>=1` it can mean one of the following:\neither _June 1. 2014_ or _June 7. 2015_ (or anything in between) \ndepending on the year and month of the overall rule.\n"]}],$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"},matchesDayOfWeekAndDay$42vt2u:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"m",ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"dateTime"}]],nm:"matchesDayOfWeekAndDay"},date:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Year"},mt:"prm",nm:"year"},{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],nm:"date"}},$at:{onDateOrAfter:{$t:{pk:".",nm:"DayOfMonth"},pa:1,mt:"a",nm:"onDateOrAfter"},dayOfWeek:{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:1,mt:"a",nm:"dayOfWeek"}},ps:[{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:1,mt:"prm",$hdn:1,nm:"dayOfWeek"},{$t:{pk:".",nm:"DayOfMonth"},pa:1,mt:"prm",$hdn:1,nm:"onDateOrAfter"}],nm:"OnFirstOfMonth"},ZoneTimeline:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"}},$at:{rule:{$t:{pk:".",nm:"ZoneRule"},pa:1,mt:"a",nm:"rule"},format:{$t:{pk:".",nm:"ZoneFormat"},pa:1,mt:"a",nm:"format"},offset:{$t:{pk:"ceylon.time",nm:"Period"},pa:1,mt:"a",nm:"offset"},until:{$t:{pk:".",nm:"ZoneUntil"},pa:1,mt:"a",nm:"until"}},ps:[{$t:{pk:"ceylon.time",nm:"Period"},pa:1,mt:"prm",$hdn:1,nm:"offset"},{$t:{pk:".",nm:"ZoneRule"},pa:1,mt:"prm",$hdn:1,nm:"rule"},{$t:{pk:".",nm:"ZoneFormat"},pa:1,mt:"prm",$hdn:1,nm:"format"},{$t:{pk:".",nm:"ZoneUntil"},pa:1,mt:"prm",$hdn:1,nm:"until"}],nm:"ZoneTimeline"},OnDay:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"OnFixedDay"},{pk:".",nm:"OnFirstOfMonth"},{pk:".",nm:"OnLastOfMonth"}],pa:257,mt:"c",an:[{doc:["Rule describing the day a rule applieds to."]}],$m:{date:{$t:{pk:"ceylon.time",nm:"Date"},pa:5,mt:"m",ps:[[{$t:{pk:".",nm:"Year"},mt:"prm",nm:"year"},{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],nm:"date"}},nm:"OnDay"},ZoneUntil:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["To represent a [[ZoneTimeline]] that continues until the present you should \nuse [[untilPresent]]"]}],$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"}},$at:{date:{$t:{pk:"ceylon.time",nm:"Date"},pa:1,mt:"a",nm:"date"},ruleDefinition:{$t:{pk:".",nm:"AtTime"},pa:1,mt:"a",nm:"ruleDefinition"}},ps:[{$t:{pk:"ceylon.time",nm:"Date"},pa:1,mt:"prm",$hdn:1,nm:"date"},{$t:{pk:".",nm:"AtTime"},pa:1,mt:"prm",$hdn:1,nm:"ruleDefinition"}],nm:"ZoneUntil"},standardZoneRule:{super:{pk:".",nm:"ZoneRule"},pa:1,mt:"o",nm:"standardZoneRule"},RealName:{pa:1,mt:"als",an:[{doc:["Canonical name of the timezone link expression"]}],$alias:{md:"$",pk:"$",nm:"String"},nm:"RealName"},Year:{pa:1,mt:"als",an:[{doc:["Alias to represent a specific year."]}],$alias:{md:"$",pk:"$",nm:"Integer"},nm:"Year"},AliasName:{pa:1,mt:"als",an:[{doc:["Alternative name (i.e. _alias_) of the time zone"]}],$alias:{md:"$",pk:"$",nm:"String"},nm:"AliasName"},"$pkg-pa":1,AtGmtTime:{super:{pk:".",nm:"AtTime"},pa:1,mt:"c",an:[{doc:["GMT time rule."]}],$at:{time$oxfz9q:{$t:{pk:"ceylon.time",nm:"Time"},mt:"a",nm:"time"}},ps:[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}],nm:"AtGmtTime"},ZoneRule:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"standardZoneRule"},{pk:".",nm:"PeriodZoneRule"},{pk:".",nm:"BasedZoneRule"}],pa:257,mt:"c",an:[{doc:["Whether daylight saving time is being observed:\n\n* [[standardZoneRule]]: A hyphen, a kind of `null` value, \n  means that we have not set our clocks ahead of standard time.\n* [[PeriodZoneRule]]: An amount of time (usually but not necessarily `1:00` meaning one hour)\n  means that we have set our clocks ahead by that amount.\n* [[BasedZoneRule]]: Some alphabetic string means that we might have set our clocks ahead;\n  and we need to check the rule the name of which is the given alphabetic string."]}],nm:"ZoneRule"},AtWallClockTime:{super:{pk:".",nm:"AtTime"},pa:1,mt:"c",an:[{doc:["Wall clock time rule.\n\nOffset from GMT varies depending wether the DST is in effect at the moment or not."]}],$at:{time$h07jro:{$t:{pk:"ceylon.time",nm:"Time"},mt:"a",nm:"time"}},ps:[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}],nm:"AtWallClockTime"},AtLocalMeanTime:{super:{pk:".",nm:"AtTime"},pa:1,mt:"c",an:[{doc:["Local mean time rule.\n\nThis has always a fixed offset from the UTC."]}],$at:{time$2ab90g:{$t:{pk:"ceylon.time",nm:"Time"},mt:"a",nm:"time"}},ps:[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}],nm:"AtLocalMeanTime"},AtTime:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"AtWallClockTime"},{pk:".",nm:"AtLocalMeanTime"},{pk:".",nm:"AtGmtTime"},{pk:".",nm:"AtUtcTime"},{pk:".",nm:"AtNauticalTime"}],pa:257,mt:"c",an:[{doc:["First, the time that something happens (in the AT column) is not necessarily the local wall clock time. \n\nThe time can be suffixed with \u2018s\u2019 (for \u201Cstandard\u201D) to mean local standard time (different from wall clock time when observing daylight saving time); \nor it can be suffixed with \u2018g\u2019, \u2018u\u2019, or \u2018z\u2019, all three of which mean the standard time at the prime meridan. \n\u2018g\u2019 stands for \u201CGMT\u201D; \n\u2018u\u2019 stands for \u201CUT\u201D or \u201CUTC\u201D (whichever was official at the time); \n\u2018z\u2019 stands for the nautical time zone Z (a.k.a. \u201CZulu\u201D which, in turn, stands for \u2018Z\u2019). \nThe time can also be suffixed with \u2018w\u2019 meaning \u201Cwall clock time;\u201D \nbut it usually isn\u2019t because that\u2019s the default."]}],$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"}},$at:{time:{$t:{pk:"ceylon.time",nm:"Time"},pa:1,mt:"a",nm:"time"},letter:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"letter"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},ps:[{$t:{pk:"ceylon.time",nm:"Time"},pa:1,mt:"prm",$hdn:1,nm:"time"},{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",$hdn:1,nm:"letter"}],nm:"AtTime"},AtUtcTime:{super:{pk:".",nm:"AtTime"},pa:1,mt:"c",an:[{doc:["UTC time rule."]}],$at:{time$cqe33g:{$t:{pk:"ceylon.time",nm:"Time"},mt:"a",nm:"time"}},ps:[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}],nm:"AtUtcTime"},AbbreviationZoneFormat:{super:{pk:".",nm:"ZoneFormat"},pa:1,mt:"c",$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"}},$at:{abbreviation:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"abbreviation"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",$hdn:1,nm:"abbreviation"}],nm:"AbbreviationZoneFormat"},standardZoneFormat:{super:{pk:".",nm:"ZoneFormat"},pa:1,mt:"o",nm:"standardZoneFormat"},PairAbbreviationZoneFormat:{super:{pk:".",nm:"ZoneFormat"},pa:1,mt:"c",$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"}},$at:{standardAbbreviation:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"standardAbbreviation"},daylightAbbreviation:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"daylightAbbreviation"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",$hdn:1,nm:"standardAbbreviation"},{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",$hdn:1,nm:"daylightAbbreviation"}],nm:"PairAbbreviationZoneFormat"},Rule:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["Timezone transition rule."]}],$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"}},$at:{onDay:{$t:{pk:".",nm:"OnDay"},pa:1,mt:"a",nm:"onDay"},save:{$t:{pk:"ceylon.time",nm:"Period"},pa:1,mt:"a",nm:"save"},letter:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"letter"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"},atTime:{$t:{pk:".",nm:"AtTime"},pa:1,mt:"a",nm:"atTime"},toYear:{$t:{pk:".",nm:"Year"},pa:1,mt:"a",nm:"toYear"},inMonth:{$t:{pk:"ceylon.time.base",nm:"Month"},pa:1,mt:"a",nm:"inMonth"},fromYear:{$t:{pk:".",nm:"Year"},pa:1,mt:"a",nm:"fromYear"}},ps:[{$t:{pk:".",nm:"Year"},pa:1,mt:"prm",nm:"fromYear"},{$t:{pk:".",nm:"Year"},pa:1,mt:"prm",nm:"toYear"},{$t:{pk:"ceylon.time.base",nm:"Month"},pa:1,mt:"prm",nm:"inMonth"},{$t:{pk:".",nm:"OnDay"},pa:1,mt:"prm",nm:"onDay"},{$t:{pk:".",nm:"AtTime"},pa:1,mt:"prm",nm:"atTime"},{$t:{pk:"ceylon.time",nm:"Period"},pa:1,mt:"prm",nm:"save"},{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",nm:"letter"}],nm:"Rule"},OnFixedDay:{super:{pk:".",nm:"OnDay"},pa:1,mt:"c",an:[{doc:["Represents a fixed day of month.\n\nFor example, a value `3` on February, 2004, means exactly _February 3. 2004_.\n"]}],$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"},date:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Year"},mt:"prm",nm:"year"},{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],nm:"date"}},$at:{fixedDate:{$t:{pk:".",nm:"DayOfMonth"},pa:1,mt:"a",nm:"fixedDate"}},ps:[{$t:{pk:".",nm:"DayOfMonth"},pa:1,mt:"prm",$hdn:1,nm:"fixedDate"}],nm:"OnFixedDay"},DayOfMonth:{pa:1,mt:"als",an:[{doc:["Alias to represent a specific day."]}],$alias:{md:"$",pk:"$",nm:"Integer"},nm:"DayOfMonth"},ReplacedZoneFormat:{super:{pk:".",nm:"ZoneFormat"},pa:1,mt:"c",$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"}},$at:{format:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"format"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",$hdn:1,nm:"format"}],nm:"ReplacedZoneFormat"},Link:{pa:1,mt:"als",an:[{doc:["Tuple representing the Timezone aliasing rules."]}],$alias:{count:2,$t:{pk:".",nm:"RealName"},pk:"$",nm:"Tuple"},nm:"Link"},BasedZoneRule:{super:{pk:".",nm:"ZoneRule"},pa:1,mt:"c",$at:{ruleName:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"ruleName"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",$hdn:1,nm:"ruleName"}],nm:"BasedZoneRule"},untilPresent:{$t:{pk:".",nm:"ZoneUntil"},pa:1,mt:"a",nm:"untilPresent"},PeriodZoneRule:{super:{pk:".",nm:"ZoneRule"},pa:1,mt:"c",$at:{period:{$t:{pk:"ceylon.time",nm:"Period"},pa:1,mt:"a",nm:"period"}},ps:[{$t:{pk:"ceylon.time",nm:"Period"},pa:1,mt:"prm",$hdn:1,nm:"period"}],nm:"PeriodZoneRule"},"$pkg-anns":[{doc:[" All the models are intended to be unrelated of the database origin.\n\nP.S.: Its not intended to be used outside of ceylon.time and currently\nits as shared because we need to test it."]},{by:["Diego Coronel","Roland Tepp"]}],OnLastOfMonth:{super:{pk:".",nm:"OnDay"},pa:1,mt:"c",an:[{doc:["Represents the last day of week, for example:\n* `lastSun`\n* `lastSat`\n\nFor example, `lastSun` of February 2015 is _February 22, 2015_"]}],$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"},date:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Year"},mt:"prm",nm:"year"},{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],nm:"date"}},$at:{dayOfWeek:{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:1,mt:"a",nm:"dayOfWeek"}},ps:[{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:1,mt:"prm",$hdn:1,nm:"dayOfWeek"}],nm:"OnLastOfMonth"},AtNauticalTime:{super:{pk:".",nm:"AtTime"},pa:1,mt:"c",an:[{doc:["Nautical time rule."]}],$at:{time$5xyi0b:{$t:{pk:"ceylon.time",nm:"Time"},mt:"a",nm:"time"}},ps:[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}],nm:"AtNauticalTime"},ZoneFormat:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"standardZoneFormat"},{pk:".",nm:"AbbreviationZoneFormat"},{pk:".",nm:"PairAbbreviationZoneFormat"},{pk:".",nm:"ReplacedZoneFormat"}],pa:257,mt:"c",an:[{doc:["It can have one of four forms:\n* [[standardZoneFormat]]: the string, \u201Czzz,\u201D which is a kind of null value\n* [[AbbreviationZoneFormat]]: a single alphabetic string other than \u201Czzz,\u201D in which case that\u2019s the abbreviation\n* [[PairAbbreviationZoneFormat]]: a pair of strings separated by a slash (\u2018\/\u2019), in which case the first string is the abbreviation for the standard time name and the second string is the abbreviation for the daylight saving time name\n* [[ReplacedZoneFormat]]: a string containing \u201C%s,\u201D in which case the \u201C%s\u201D will be replaced by the text in the appropriate Rule\u2019s LETTER column"]}],nm:"ZoneFormat"}},"$mod-anns":[{doc:["Date and Time library for Ceylon language SDK.\n\nThis library is loosely modeled\/inspired by the JodaTime\/JSR-310 date\/time library.\n"]},{by:["Diego Coronel","Roland Tepp"]}],"ceylon.time.internal":{GregorianZonedDateTime:{super:{md:"$",pk:"$",nm:"Object"},pa:1,mt:"c",an:[{doc:["Default implementation of gregorian calendar thats makes use of a [[TimeZone]] for it´s operations.\n\nThis means that making some operations like _plusDays_ takes into \naccount the result Instant generated to reapply all the rules of the current TimeZone."]}],sts:[{pk:"ceylon.time.timezone",nm:"ZoneDateTime"}],$m:{withMilliseconds:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[ZoneDateTime]] with the _milliseconds_ value set to the specified value.\n\n**Note 01:** It should be a valid _millisecond_.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"withMilliseconds"},plusDays:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Adds number of days from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"plusDays"},withMinutes:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[ZoneDateTime]] with the _minute_ value set to the specified value.\n\n**Note 01:** It should be a valid _minute_.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"withMinutes"},withMonth:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[ZoneDateTime]] with the _month_ value set to the specified value.\n\n**Note 01:** It should result in a valid gregorian date.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],nm:"withMonth"},minusHours:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of hours from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"minusHours"},adjust$npr8ju:{$t:{pk:".",nm:"GregorianZonedDateTime"},mt:"m",an:[{doc:["Fix [[DateTime]] zone absence."]}],ps:[[{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"prm",nm:"resolved"}]],nm:"adjust"},withWeekOfYear:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[ZoneDateTime]] with the _week of year_ value set to the specified value."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weekNumber"}]],nm:"withWeekOfYear"},plusSeconds:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Adds number of seconds from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"plusSeconds"},minusMilliseconds:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of milliseconds from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"minusMilliseconds"},withDayOfYear:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[ZoneDateTime]] with the _day of year_ value set to the specified value."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfYear"}]],nm:"withDayOfYear"},withDayOfWeek:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[ZoneDateTime]] with the _day of week_ value set to the specified value."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},mt:"prm",nm:"dayOfWeek"}]],nm:"withDayOfWeek"},withSeconds:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[ZoneDateTime]] with the _second_ value set to the specified value.\n\n**Note 01:** It should be a valid _second_.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"withSeconds"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},mt:"prm",nm:"other"}]],nm:"offset"},neighbour:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"neighbour"},plusMinutes:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Adds number of minutes from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"plusMinutes"},withDay:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[ZoneDateTime]] with the _day of month_ value set to the specified value.\n\n**Note 01:** It should result in a valid gregorian date.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfMonth"}]],nm:"withDay"},minusSeconds:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of seconds from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"minusSeconds"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,mt:"m",an:[{doc:["Comparing [[ZoneDateTime]] is based on [[Instant]] and should not be\ncompared as it´s human representation as they are adjusted based on geographic and regional (DST)\nlocations and do not represent a comparison correct."]}],ps:[[{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},mt:"prm",nm:"other"}]],nm:"compare"},minusMinutes:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of minutes from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"minusMinutes"},minusYears:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of years from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note 01:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2012, 2, 29).minusYears(1)` will return\n`2011-02-28`, since _February 2011_ has only 28 days.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"minusYears"},plusHours:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Adds number of hours from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"plusHours"},minusDays:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of days from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"minusDays"},minusMonths:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of months from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note 01:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2013, 3, 30).minusMonths(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"minusMonths"},minusWeeks:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of weeks from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],nm:"minusWeeks"},plusMonths:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Adds number of months to this _zoned date and time_ and returns the resulting date.\n\n**Note:** Day of month value of the resulting date will be truncated to the\nvalid range of the target date if necessary.\n\nThis means for example, that `date(2013, 1, 31).plusMonths(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"plusMonths"},plusMilliseconds:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Adds number of milliseconds from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"plusMilliseconds"},plusWeeks:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Adds number of weeks from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],nm:"plusWeeks"},plusYears:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Adds number of years to this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note 01:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2012, 2, 29).plusYears(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"plusYears"},withHours:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[ZoneDateTime]] with the _hour_ value set to the specified value.\n\n**Note 01:** It should be a valid _hour_.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"withHours"},withYear:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[ZoneDateTime]] with the _year_ value set to the specified value.\n\n**Note 01:** It should result in a valid gregorian date.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],nm:"withYear"}},$at:{successor:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"g",an:[{doc:["For successor its used the lowest unit of time, this way we can benefit\nfrom maximum precision. In this case the successor is the current value plus 1 millisecond.\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],nm:"successor"},minutes:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of minutes since last full hour."]}],nm:"minutes"},dateTime:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"g",an:[{doc:["Returns [[ceylon.time::DateTime]] representation of this zoned _date and time_."]}],nm:"dateTime"},hours:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of full hours elapsed since last midnight."]}],nm:"hours"},secondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of seconds since last midnight."]}],nm:"secondsOfDay"},timeZone:{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},pa:3,mt:"a",an:[{doc:["TimeZone to be applied in this implementation."]}],nm:"timeZone"},leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"g",an:[{doc:["Returns `true`, if this is a leap year according to gregorian calendar leap year rules."]}],nm:"leapYear"},date:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"g",an:[{doc:["Returns [[ceylon.time::Date]] representation of current zoned _date and time_."]}],nm:"date"},dayOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns _day of year_ value of this gregorian date."]}],nm:"dayOfYear"},predecessor:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"g",an:[{doc:["For predecessor its used the lowest unit of time, this way we can benefit\nfrom maximum precision. In this case the predecessor is the current value minus 1 millisecond.\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]}],nm:"predecessor"},millisecondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of milliseconds since last midnight."]}],nm:"millisecondsOfDay"},time:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"g",an:[{doc:["Returns [[ceylon.time::Time]] representation of current zoned _date and time_."]}],nm:"time"},seconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of seconds since last minute."]}],nm:"seconds"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:[{doc:["Returns ISO-8601 formatted String representation of this _time of day_.\n\nReference: https:\/\/en.wikipedia.org\/wiki\/ISO_8601#Time_offsets_from_UTC"]}],nm:"string"},month:{$t:{pk:"ceylon.time.base",nm:"Month"},pa:3,mt:"g",an:[{doc:["Returns month of this gregorian date."]}],nm:"month"},year:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns year of this gregorian date."]}],nm:"year"},weekOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns week of year according to ISO-8601 week number calculation rules."]}],nm:"weekOfYear"},dayOfEra:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns _day of year_ value of this gregorian date."]}],nm:"dayOfEra"},day:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns _day of month_ value of this gregorian date."]}],nm:"day"},instant:{$t:{pk:"ceylon.time",nm:"Instant"},pa:3,mt:"a",an:[{doc:["All operations of this implementations is based in this Instant."]}],nm:"instant"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of milliseconds since last full second."]}],nm:"milliseconds"},dayOfWeek:{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:3,mt:"g",an:[{doc:["Returns current day of the week."]}],nm:"dayOfWeek"},minutesOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of minutes since last midnight."]}],nm:"minutesOfDay"}},ps:[{$t:{pk:"ceylon.time",nm:"Instant"},pa:3,mt:"prm",an:[{doc:["All operations of this implementations is based in this Instant."]}],$hdn:1,nm:"instant"},{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,pa:3,mt:"prm",an:[{doc:["TimeZone to be applied in this implementation."]}],$hdn:1,nm:"timeZone"}],nm:"GregorianZonedDateTime"},gregorianYearMonth:{$t:{pk:"ceylon.time",nm:"YearMonth"},pa:1,mt:"m",an:[{doc:["Returns a gregorian year and month calendar according to the specified year and month values."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",an:[{doc:["Year number of the date"]}],$hdn:1,nm:"year"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:"ceylon.time.base",nm:"Month"}]},mt:"prm",an:[{doc:["Month of the year"]}],$hdn:1,nm:"month"}]],nm:"gregorianYearMonth"},overlap:{$t:{comp:"u",l:[{md:"$",ta:{"Tuple.First":{nm:"Value"},"Tuple.Element":{comp:"u",l:[{nm:"Value"},{nm:"Value"}]},"Tuple.Rest":{md:"$",ta:{"Tuple.First":{nm:"Value"},"Tuple.Element":{nm:"Value"},"Tuple.Rest":{md:"$",pk:"$",nm:"Empty"}},pk:"$",nm:"Tuple"}},pk:"$",nm:"Tuple"},{md:"$",pk:"$",nm:"Empty"}]},pa:1,mt:"m",an:[{doc:["Returns the inclusive overlap between two ordinal ranges.\n\nThe range of the overlap will be returned in the natural order of the values regardless of their original order in input tuples.\n\nExamples:\n\n    assert(overlap([1, 3], [2, 4]) == [2, 3]);\n    assert(overlap([4, 2], [1, 3]) == [2, 3]);\n    assert(is Empty o = overlap([1, 2], [3, 4]));\n"]}],tp:[{sts:[{md:"$",ta:{"Enumerable.Other":{nm:"Value"}},pk:"$",nm:"Enumerable"},{md:"$",ta:{"Comparable.Other":{nm:"Value"}},pk:"$",nm:"Comparable"}],nm:"Value"}],ps:[[{$t:{md:"$",ta:{"Tuple.First":{nm:"Value"},"Tuple.Element":{comp:"u",l:[{nm:"Value"},{nm:"Value"}]},"Tuple.Rest":{md:"$",ta:{"Tuple.First":{nm:"Value"},"Tuple.Element":{nm:"Value"},"Tuple.Rest":{md:"$",pk:"$",nm:"Empty"}},pk:"$",nm:"Tuple"}},pk:"$",nm:"Tuple"},mt:"prm",nm:"first"},{$t:{md:"$",ta:{"Tuple.First":{nm:"Value"},"Tuple.Element":{comp:"u",l:[{nm:"Value"},{nm:"Value"}]},"Tuple.Rest":{md:"$",ta:{"Tuple.First":{nm:"Value"},"Tuple.Element":{nm:"Value"},"Tuple.Rest":{md:"$",pk:"$",nm:"Empty"}},pk:"$",nm:"Tuple"}},pk:"$",nm:"Tuple"},mt:"prm",nm:"second"}]],nm:"overlap"},TimeOfDay:{super:{md:"$",pk:"$",nm:"Object"},pa:1,mt:"c",an:[{doc:["Basic implementation of [[Time]] interface, representing an abstract \n_time of day_ such as _10am_ or _3.20pm_ with a precision of milliseconds."]}],sts:[{pk:"ceylon.time",nm:"Time"}],$m:{plus:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Adds specified time period to this time of day\nand returns the result as new time of day."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableTimePeriod"},mt:"prm",nm:"period"}]],nm:"plus"},withMilliseconds:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Returns a copy of this Time replacing the _milliseconds_ value.\n\n**Note:** It should be a valid _millisecond_."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"withMilliseconds"},minusSeconds:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Subtracts specified number of seconds from this time of day\nand returns the result as new time of day."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"minusSeconds"},minus:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Subtracts specified time period from this time of day\nand returns the result as new time of day."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableTimePeriod"},mt:"prm",nm:"period"}]],nm:"minus"},periodTo:{$t:{pk:"ceylon.time",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns the period between this and the given time.\n\nIf this time is after the given time then return zero period."]}],ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"end"}]],nm:"periodTo"},withMinutes:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Returns a copy of this Time replacing the _minutes_ value.\n\n**Note:** It should be a valid _minute_."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"withMinutes"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,mt:"m",an:[{doc:["Compare two instances of _time of day_."]}],ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"other"}]],nm:"compare"},minusMinutes:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Subtracts specified number of minutes from this time of day \nand returns the result as new  time of day."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"minusMinutes"},plusHours:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Adds specified number of hours to this time of day\nand returns the result as new time of day."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"plusHours"},periodFrom:{$t:{pk:"ceylon.time",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns the period between this and the given time.\n\nIf this time is before the given time then return zero period."]}],ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"start"}]],nm:"periodFrom"},minusHours:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Subtracts specified number of hours from this time of day \nand returns the result as new time of day."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"minusHours"},rangeTo:{$t:{pk:"ceylon.time",nm:"TimeRange"},pa:3,mt:"m",an:[{doc:["Returns the [[TimeRange]] between this and given Time."]}],ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"other"}]],nm:"rangeTo"},plusSeconds:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Adds specified number of seconds to this time of day\nand returns the result as new time of day."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"plusSeconds"},plusMilliseconds:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Adds specified number of milliseconds to this time of day\nand returns the result as new time of day."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"plusMilliseconds"},minusMilliseconds:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Subtracts specified number of milliseconds from this time of day\nand returns the result as new time of day."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"minusMilliseconds"},withHours:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Returns a copy of this Time replacing the _hours_ value.\n\n**Note:** It should be a valid _hour_."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"withHours"},withSeconds:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Returns a copy of this Time replacing the _seconds_ value.\n\n**Note:** It should be a valid _second_."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"withSeconds"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"other"}]],nm:"offset"},neighbour:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"neighbour"},plusMinutes:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"m",an:[{doc:["Adds specified number of minutes to this time of day \nand returns the result as new  time of day."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"plusMinutes"}},$at:{predecessor:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"g",an:[{doc:["For predecessor its used the lowest unit of time, this way we can benefit\nfrom maximum precision. In this case the predecessor is the current value minus 1 millisecond."]}],nm:"predecessor"},millisecondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{doc:["Number of milliseconds since last midnight."]}],nm:"millisecondsOfDay"},successor:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"g",an:[{doc:["For successor its used the lowest unit of time, this way we can benefit\nfrom maximum precision. In this case the successor is the current value plus 1 millisecond."]}],nm:"successor"},minutes:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of minutes since last full hour."]}],nm:"minutes"},seconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of seconds since last minute."]}],nm:"seconds"},hours:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of full hours elapsed since last midnight."]}],nm:"hours"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:[{doc:["Returns ISO-8601 formatted String representation of this _time of day_.\n\nReference: https:\/\/en.wikipedia.org\/wiki\/ISO_8601#Times"]}],nm:"string"},secondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of seconds since last midnight."]}],nm:"secondsOfDay"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of milliseconds since last full second."]}],nm:"milliseconds"},minutesOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of minutes since last midnight."]}],nm:"minutesOfDay"}},ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"prm",an:[{doc:["Number of milliseconds since last midnight."]}],$hdn:1,nm:"millisecondsOfDay"}],nm:"TimeOfDay"},GregorianDate:{super:{md:"$",pk:"$",nm:"Object"},pa:1,mt:"c",an:[{doc:["Default implementation of a gregorian calendar"]}],sts:[{pk:"ceylon.time",nm:"Date"}],$m:{plus:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Adds specified date period to this date and returns the new [[Date]]."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableDatePeriod"},mt:"prm",nm:"amount"}]],nm:"plus"},minus:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Subtracts specified date period from this date and returns the new [[Date]]."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableDatePeriod"},mt:"prm",nm:"amount"}]],nm:"minus"},plusDays:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Adds number of days to this date and returns the resulting [[Date]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"plusDays"},periodTo:{$t:{pk:"ceylon.time",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns the period between this and the given date.\n\nIf this date is after the given date then return negative period."]}],ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"end"}]],nm:"periodTo"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,mt:"m",an:[{doc:["Dates from same chronology can be compared if they have same _day of era_."]}],ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"other"}]],nm:"compare"},at:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[DateTime]] value."]}],ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}]],nm:"at"},addPeriod$2sk1dc:{$t:{pk:"ceylon.time",nm:"Date"},mt:"m",an:[{doc:["This method add the specified fields doing first the subtraction and last the additions.\n\nThe mix between positive and negative fields does not guarantee any expected behavior."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"addPeriod"},minusYears:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Subtracts number of years from this date returning the resulting the new gregorian date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2012, 2, 29).minusYears(1)` will return\n`2011-02-28`, since _February 2011_ has only 28 days.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"minusYears"},withMonth:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Returns new date with the month set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],nm:"withMonth"},minusDays:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Subtracts number of days from this date and returns the resulting [[Date]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"minusDays"},periodFrom:{$t:{pk:"ceylon.time",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns the period between this and the given date.\n\nIf this date is before the given date then return negative period."]}],ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"start"}]],nm:"periodFrom"},minusMonths:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Subtracts number of months from this date and returns the resulting date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2013, 3, 30).minusMonths(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"minusMonths"},withWeekOfYear:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Returns new date with the specified weekOfYear value.\n\n**Note:** It should result in a valid gregorian date.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weekOfYear"}]],nm:"withWeekOfYear"},minusWeeks:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Subtracts number of weeks from this date and returns the resulting [[Date]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],nm:"minusWeeks"},rangeTo:{$t:{pk:"ceylon.time",nm:"DateRange"},pa:3,mt:"m",an:[{doc:["Returns the [[DateRange]] between this and given Date."]}],ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"other"}]],nm:"rangeTo"},plusMonths:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Adds number of months to this date and returns the resulting date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2013, 1, 31).plusMonths(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"plusMonths"},plusWeeks:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Adds number of weeks to this date and returns the resulting [[Date]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],nm:"plusWeeks"},plusYears:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Adds number of years to this date returning the resulting gregorian date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2012, 2, 29).plusYears(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"plusYears"},withDayOfYear:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfYear"}]],nm:"withDayOfYear"},withDayOfWeek:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},mt:"prm",nm:"dayOfWeek"}]],nm:"withDayOfWeek"},withYear:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Returns new date with the specified year value.\n\n**Note:** It should result in a valid gregorian date.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],nm:"withYear"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"other"}]],nm:"offset"},neighbour:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"neighbour"},withDay:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"m",an:[{doc:["Returns new date with the _day of month_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"day"}]],nm:"withDay"}},$at:{predecessor:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"g",an:[{doc:["Returns gregorian date immediately preceding this date.\n\nFor successor its used the lowest unit of date, this way we can benefit\nfrom maximum precision. In this case the successor is the current value minus 1 day."]}],nm:"predecessor"},successor:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"g",an:[{doc:["Returns gregorian date immediately succeeding this date.\n\nFor successor its used the lowest unit of date, this way we can benefit\nfrom maximum precision. In this case the successor is the current value plus 1 day."]}],nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:[{doc:["Returns ISO-8601 formatted String representation of this date.\n\nReference: https:\/\/en.wikipedia.org\/wiki\/ISO_8601#Dates"]}],nm:"string"},month:{$t:{pk:"ceylon.time.base",nm:"Month"},pa:3,mt:"g",an:[{doc:["Returns month of this gregorian date."]}],nm:"month"},weekOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns week of year according to ISO-8601 week number calculation rules."]}],$m:{normalizeFirstWeek$7b8vj7:{$t:{pk:"ceylon.time",nm:"Date"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"yearNumber"}]],nm:"normalizeFirstWeek"},normalizeLastWeek$ekrdod:{$t:{pk:"ceylon.time",nm:"Date"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"yearNumber"}]],nm:"normalizeLastWeek"}},nm:"weekOfYear"},year:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns year of this gregorian date."]}],nm:"year"},dayOfEra:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:[{doc:["Every [[Date]] implementation should indicate it´s own _day of era_ based in it´s own chronology."]}],nm:"dayOfEra"},leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"g",an:[{doc:["Returns `true`, if this is a leap year according to gregorian calendar leap year rules."]}],nm:"leapYear"},day:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns _day of month_ value of this gregorian date."]}],nm:"day"},dayOfWeek:{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:3,mt:"g",an:[{doc:["Returns current day of the week."]}],nm:"dayOfWeek"},dayOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns _day of year_ value of this gregorian date."]}],nm:"dayOfYear"}},ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"prm",an:[{doc:["Every [[Date]] implementation should indicate it´s own _day of era_ based in it´s own chronology."]}],$hdn:1,nm:"dayOfEra"}],nm:"GregorianDate"},intersect:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,mt:"m",an:[{doc:["Returns if two ranges has intersection."]}],tp:[{sts:[{md:"$",ta:{"Comparable.Other":{nm:"Value"}},pk:"$",nm:"Comparable"}],nm:"Value"}],ps:[[{$t:{nm:"Value"},mt:"prm",nm:"start"},{$t:{nm:"Value"},mt:"prm",nm:"end"},{$t:{nm:"Value"},mt:"prm",nm:"otherStart"},{$t:{nm:"Value"},mt:"prm",nm:"otherEnd"}]],nm:"intersect"},gregorianDate:{$t:{pk:"ceylon.time",nm:"Date"},pa:1,mt:"m",an:[{doc:["Returns a gregorian calendar date according to the specified year, month and date values."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",an:[{doc:["Year number of the date"]}],$hdn:1,nm:"year"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:"ceylon.time.base",nm:"Month"}]},mt:"prm",an:[{doc:["Month of the year"]}],$hdn:1,nm:"month"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",an:[{doc:["Day of month"]}],$hdn:1,nm:"day"}]],nm:"gregorianDate"},"$pkg-anns":[{by:["Diego Coronel","Roland Tepp"]}],"$pkg-pa":1,GregorianYearMonth:{super:{md:"$",pk:"$",nm:"Object"},pa:1,mt:"c",sts:[{pk:"ceylon.time",nm:"YearMonth"}],$m:{countInMonths$9amdcu:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"m",ps:[[{$t:{pk:"ceylon.time",nm:"YearMonth"},mt:"prm",nm:"yearMonth"}]],nm:"countInMonths"},minusMonths:{$t:{pk:"ceylon.time",nm:"YearMonth"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"minusMonths"},plusMonths:{$t:{pk:"ceylon.time",nm:"YearMonth"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"plusMonths"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.time",nm:"YearMonth"},mt:"prm",nm:"other"}]],nm:"compare"},minusYears:{$t:{pk:"ceylon.time",nm:"YearMonth"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"minusYears"},plusYears:{$t:{pk:"ceylon.time",nm:"YearMonth"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"plusYears"},withYear:{$t:{pk:"ceylon.time",nm:"YearMonth"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],nm:"withYear"},withMonth:{$t:{pk:"ceylon.time",nm:"YearMonth"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],nm:"withMonth"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.time",nm:"YearMonth"},mt:"prm",nm:"other"}]],nm:"offset"},neighbour:{$t:{pk:"ceylon.time",nm:"YearMonth"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"neighbour"}},$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:[{doc:["Returns ISO-8601 formatted String representation of this year and month moment.\n\nReference: https:\/\/en.wikipedia.org\/wiki\/ISO_8601"]}],nm:"string"},month:{$t:{pk:"ceylon.time.base",nm:"Month"},pa:3,mt:"a",nm:"month"},year:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",nm:"year"},leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"g",nm:"leapYear"}},ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"prm",$hdn:1,nm:"year"},{$t:{pk:"ceylon.time.base",nm:"Month"},pa:3,mt:"prm",$hdn:1,nm:"month"}],nm:"GregorianYearMonth"},gap:{$t:{comp:"u",l:[{md:"$",ta:{"Tuple.First":{nm:"Value"},"Tuple.Element":{comp:"u",l:[{nm:"Value"},{nm:"Value"}]},"Tuple.Rest":{md:"$",ta:{"Tuple.First":{nm:"Value"},"Tuple.Element":{nm:"Value"},"Tuple.Rest":{md:"$",pk:"$",nm:"Empty"}},pk:"$",nm:"Tuple"}},pk:"$",nm:"Tuple"},{md:"$",pk:"$",nm:"Empty"}]},pa:1,mt:"m",an:[{doc:["Returns a tuple representing an exclusive gap between two disjoint ranges of ordinal values.\n\nValues in the tuple are returned always in their natural order regardless of their original ordering in the input tuples. \nIf input ranges are overlapping, this function will return an empty value.\n\nExamples:\n\n    assert(gap([1, 2], [5, 6]) == [3, 4]);\n    assert(gap([6, 5], [1, 2]) == [3, 4]);\n    assert(is Empty g = gap([1, 3], [2, 4]));\n"]}],tp:[{sts:[{md:"$",ta:{"Comparable.Other":{nm:"Value"}},pk:"$",nm:"Comparable"},{md:"$",ta:{"Enumerable.Other":{nm:"Value"}},pk:"$",nm:"Enumerable"}],nm:"Value"}],ps:[[{$t:{md:"$",ta:{"Tuple.First":{nm:"Value"},"Tuple.Element":{comp:"u",l:[{nm:"Value"},{nm:"Value"}]},"Tuple.Rest":{md:"$",ta:{"Tuple.First":{nm:"Value"},"Tuple.Element":{nm:"Value"},"Tuple.Rest":{md:"$",pk:"$",nm:"Empty"}},pk:"$",nm:"Tuple"}},pk:"$",nm:"Tuple"},mt:"prm",nm:"first"},{$t:{md:"$",ta:{"Tuple.First":{nm:"Value"},"Tuple.Element":{comp:"u",l:[{nm:"Value"},{nm:"Value"}]},"Tuple.Rest":{md:"$",ta:{"Tuple.First":{nm:"Value"},"Tuple.Element":{nm:"Value"},"Tuple.Rest":{md:"$",pk:"$",nm:"Empty"}},pk:"$",nm:"Tuple"}},pk:"$",nm:"Tuple"},mt:"prm",nm:"second"}]],nm:"gap"},GregorianDateTime:{super:{md:"$",pk:"$",nm:"Object"},pa:1,mt:"c",an:[{doc:["Default implementation of a gregorian calendar"]}],sts:[{pk:"ceylon.time",nm:"DateTime"}],$m:{withMilliseconds:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[DateTime]] with the _milliseconds_ value set to the specified value.\n\n**Note:** It should be a valid _millisecond_.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"withMilliseconds"},plusDays:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Adds number of days to this date and returns the resulting [[DateTime]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"plusDays"},periodTo:{$t:{pk:"ceylon.time",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns the period between this and the given [[DateTime]].\n\nIf this [[DateTime]] is after the given [[DateTime]] then return negative period."]}],ps:[[{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"prm",nm:"end"}]],nm:"periodTo"},withMinutes:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[DateTime]] with the _minutes_ value set to the specified value.\n\n**Note:** It should be a valid _minute_.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"withMinutes"},withMonth:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[DateTime]] with the _month_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],nm:"withMonth"},periodFrom:{$t:{pk:"ceylon.time",nm:"Period"},pa:3,mt:"m",an:[{doc:["Returns the period between this and the given [[DateTime]].\n\nIf this [[DateTime]] is before the given [[DateTime]] then return negative period."]}],ps:[[{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"prm",nm:"start"}]],nm:"periodFrom"},minusHours:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of hours from this _date and time_ and returns the resulting [[DateTime]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"minusHours"},withWeekOfYear:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[DateTime]] with the _week of year_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weekNumber"}]],nm:"withWeekOfYear"},plusSeconds:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Adds number of seconds from this _date and time_ and returns the resulting [[DateTime]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"plusSeconds"},minusMilliseconds:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of milliseconds from this _date and time_ and returns the resulting [[DateTime]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"minusMilliseconds"},withSeconds:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[DateTime]] with the _seconds_ value set to the specified value.\n\n**Note:** It should be a valid _second_.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"withSeconds"},withDayOfWeek:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[DateTime]] with the _day of week_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},mt:"prm",nm:"dayOfWeek"}]],nm:"withDayOfWeek"},withDayOfYear:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[DateTime]] with the _day of week_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfYear"}]],nm:"withDayOfYear"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"prm",nm:"other"}]],nm:"offset"},neighbour:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"neighbour"},instant:{$t:{pk:"ceylon.time",nm:"Instant"},pa:3,mt:"m",an:[{doc:["[[DateTime]] does not know anything about [[TimeZone]] and it should be supplied to\ncreate a [[Instant]]."]}],ps:[[{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],nm:"instant"},plusMinutes:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Adds number of minutes from this _date and time_ and returns the resulting [[DateTime]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"plusMinutes"},withDay:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[DateTime]] with the _day of month_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfMonth"}]],nm:"withDay"},plus:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Adds specified date period to this date and returns the new [[DateTime]]."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadablePeriod"},mt:"prm",nm:"amount"}]],nm:"plus"},minus:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Subtracts specified date period from this date and returns the new [[DateTime]]."]}],ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadablePeriod"},mt:"prm",nm:"amount"}]],nm:"minus"},minusSeconds:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of seconds from this _date and time_ and returns the resulting [[DateTime]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"minusSeconds"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,mt:"m",an:[{doc:["Comparing [[DateTime]] is based on [[Date]] and [[Time]] comparison."]}],ps:[[{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"prm",nm:"other"}]],nm:"compare"},minusMinutes:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of minutes from this _date and time_ and returns the resulting [[DateTime]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"minusMinutes"},minusYears:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of years from this date returning the resulting the new gregorian date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2012, 2, 29).minusYears(1)` will return\n`2011-02-28`, since _February 2011_ has only 28 days.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"minusYears"},plusHours:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Adds number of hours from this _date and time_ and returns the resulting [[DateTime]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"plusHours"},minusDays:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of days from this date and returns the resulting [[DateTime]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"minusDays"},addPeriod$g15ssb:{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"m",an:[{doc:["This method add the specified fields doing first the subtraction and last the additions.\n\nThe mix between positive and negative fields does not guarantee any expected behavior."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"addPeriod"},fromTime$uyune6:{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"m",an:[{doc:["Calculates the based in given time, consuming it for each day if necessary."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"hours"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"minutes"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"seconds"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"millis"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"signal"}]],nm:"fromTime"},minusMonths:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of months from this date and returns the resulting date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2013, 3, 30).minusMonths(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"minusMonths"},minusWeeks:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Subtracts number of weeks from this date and returns the resulting [[DateTime]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],nm:"minusWeeks"},rangeTo:{$t:{pk:"ceylon.time",nm:"DateTimeRange"},pa:3,mt:"m",an:[{doc:["Returns the [[DateTimeRange]] between this and given DateTime."]}],ps:[[{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"prm",nm:"other"}]],nm:"rangeTo"},plusMonths:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Adds number of months to this date and returns the resulting date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2013, 1, 31).plusMonths(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"plusMonths"},plusWeeks:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Adds number of weeks to this date and returns the resulting [[DateTime]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],nm:"plusWeeks"},plusMilliseconds:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Adds number of milliseconds from this _date and time_ and returns the resulting [[DateTime]]."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"plusMilliseconds"},plusYears:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Adds number of years to this date returning the resulting gregorian date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2012, 2, 29).plusYears(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"plusYears"},withHours:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[DateTime]] with the _hours_ value set to the specified value.\n\n**Note:** It should be a valid _hour_.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"withHours"},withYear:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"m",an:[{doc:["Returns new [[DateTime]] with the _year_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],nm:"withYear"}},$at:{successor:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"g",an:[{doc:["For successor its used the lowest unit of time, this way we can benefit\nfrom maximum precision. In this case the successor is the current value minus 1 millisecond.\n"]}],nm:"successor"},minutes:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of minutes since last full hour."]}],nm:"minutes"},hours:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of full hours elapsed since last midnight."]}],nm:"hours"},secondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of seconds since last midnight."]}],nm:"secondsOfDay"},leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"g",an:[{doc:["Returns `true` if this is a leap year according to gregorian calendar leap year rules."]}],nm:"leapYear"},date:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"a",an:[{doc:["Returns [[Date]] representation of current _date and time_."]}],nm:"date"},dayOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns _day of year_ value of this gregorian date."]}],nm:"dayOfYear"},predecessor:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"g",an:[{doc:["For predecessor its used the lowest unit of time, this way we can benefit\nfrom maximum precision. In this case the predecessor is the current value minus 1 millisecond.\n"]}],nm:"predecessor"},millisecondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of milliseconds since last midnight."]}],nm:"millisecondsOfDay"},time:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"a",an:[{doc:["Returns [[Time]] representation of current _date and time_."]}],nm:"time"},seconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of seconds since last minute."]}],nm:"seconds"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:[{doc:["Returns ISO-8601 formatted String representation of this _Date and Time of day_.\n\nhttps:\/\/en.wikipedia.org\/wiki\/ISO_8601#Combined_date_and_time_representations"]}],nm:"string"},month:{$t:{pk:"ceylon.time.base",nm:"Month"},pa:3,mt:"g",an:[{doc:["Returns month of this gregorian date."]}],nm:"month"},dayOfEra:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns _day of year_ value of this gregorian date."]}],nm:"dayOfEra"},year:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns year of this gregorian date."]}],nm:"year"},weekOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns week of year according to ISO-8601 week number calculation rules."]}],nm:"weekOfYear"},day:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Returns _day of month_ value of this gregorian date."]}],nm:"day"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of milliseconds since last full second."]}],nm:"milliseconds"},minutesOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:[{doc:["Number of minutes since last midnight."]}],nm:"minutesOfDay"},dayOfWeek:{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:3,mt:"g",an:[{doc:["Returns current day of the week."]}],nm:"dayOfWeek"}},ps:[{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"prm",an:[{doc:["Returns [[Date]] representation of current _date and time_."]}],$hdn:1,nm:"date"},{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"prm",an:[{doc:["Returns [[Time]] representation of current _date and time_."]}],$hdn:1,nm:"time"}],nm:"GregorianDateTime"}},"ceylon.time.base":{monday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",an:[{doc:["_Monday_ is the day of the week that follows Sunday and precedes Tuesday."]}],$at:{predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"monday"},ReadableTime:{pa:1,mt:"i",an:[{doc:["Common interface capable of representing _time of day_."]},{see:["Time","DateTime","ZoneDateTime"]}],$at:{millisecondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Number of milliseconds since the beginning of the day."]}],nm:"millisecondsOfDay"},minutes:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Number of minutes since last full hour."]}],nm:"minutes"},seconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Number of seconds since last minute."]}],nm:"seconds"},hours:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Hour of day."]}],nm:"hours"},secondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Number of seconds since the beginning of the day."]}],nm:"secondsOfDay"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Number of milliseconds since last second."]}],nm:"milliseconds"},minutesOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Number of minutes since the beginning of the day."]}],nm:"minutesOfDay"}},nm:"ReadableTime"},Month:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"january"},{pk:".",nm:"february"},{pk:".",nm:"march"},{pk:".",nm:"april"},{pk:".",nm:"may"},{pk:".",nm:"june"},{pk:".",nm:"july"},{pk:".",nm:"august"},{pk:".",nm:"september"},{pk:".",nm:"october"},{pk:".",nm:"november"},{pk:".",nm:"december"}],pa:257,mt:"c",an:[{doc:["A month in a Gregorian or Julian calendar system."]}],sts:[{md:"$",ta:{"Ordinal.Other":{pk:".",nm:"Month"}},pk:"$",nm:"Ordinal"},{md:"$",ta:{"Comparable.Other":{pk:".",nm:"Month"}},pk:"$",nm:"Comparable"},{md:"$",ta:{"Enumerable.Other":{pk:".",nm:"Month"}},pk:"$",nm:"Enumerable"}],$m:{minusMonths:{$t:{pk:".",nm:"Month"},pa:1,mt:"m",an:[{doc:["Returns month of year that comes specified number of months before this month."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"number"}]],nm:"minusMonths"},firstDayOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:9,mt:"m",an:[{doc:["Returns the _day of year_ value for first of this month."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"leapYear"}]],nm:"firstDayOfYear"},plusMonths:{$t:{pk:".",nm:"Month"},pa:1,mt:"m",an:[{doc:["Returns month of year that comes specified number of months after this month."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"number"}]],nm:"plusMonths"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,mt:"m",an:[{doc:["Compares ordinal numbers of two instances of `Month`."]}],ps:[[{$t:{pk:".",nm:"Month"},mt:"prm",nm:"other"}]],nm:"compare"},neighbour:{$t:{pk:".",nm:"Month"},pa:3,mt:"m",an:[{doc:["returns `n`-th neighbour of this _day of week_.\n\nFor example:\n\n    assert(january.neighbour(0)  == january);\n    assert(january.neighbour(1)  == february);\n    assert(january.neighbour(-1) == december);\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"neighbour"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:11,mt:"m",an:[{doc:["Returns the offset of the other _month_ compared to this.\n\nThis will always return positive integer such that given any\ntwo months `a` and `b`, the following is always true:\n\n   assert(0 <= a.offset(b) <= 11);\n"]}],ps:[[{$t:{pk:".",nm:"Month"},mt:"prm",nm:"other"}]],nm:"offset"},add:{$t:{pk:".",nm:"Month.Overflow"},pa:1,mt:"m",an:[{doc:["Adds number of months to this month and returns the result \nas new month value and number of times the operation overflowed."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"numberOfMonths"}]],nm:"add"},numberOfDays:{$t:{md:"$",pk:"$",nm:"Integer"},pa:9,mt:"m",an:[{doc:["Returns number of days in this month."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"leapYear"}]],nm:"numberOfDays"}},$c:{Overflow:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:[{doc:["A result of adding or subtracting a month to another amount."]}],$at:{month:{$t:{pk:".",nm:"Month"},pa:1,mt:"a",an:[{doc:["New month value."]}],nm:"month"},years:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["Number of years overflowed by calculation."]}],nm:"years"}},ps:[{$t:{pk:".",nm:"Month"},pa:1,mt:"prm",an:[{doc:["New month value."]}],$hdn:1,nm:"month"},{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"prm",an:[{doc:["Number of years overflowed by calculation."]}],$hdn:1,nm:"years"}],nm:"Overflow"}},$at:{integer:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["Ordinal number of the month of year.\n   Where:\n\n   january  = 1\n\n   february = 2\n\n   ...\n\n   december = 12"]}],nm:"integer"}},ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"prm",an:[{doc:["Ordinal number of the month of year.\n   Where:\n\n   january  = 1\n\n   february = 2\n\n   ...\n\n   december = 12"]}],$hdn:1,nm:"integer"}],nm:"Month"},DayOfWeek:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"monday"},{pk:".",nm:"tuesday"},{pk:".",nm:"wednesday"},{pk:".",nm:"thursday"},{pk:".",nm:"friday"},{pk:".",nm:"saturday"},{pk:".",nm:"sunday"}],pa:257,mt:"c",an:[{doc:["A day of week, such as 'tuesday'.\n\nThis class satisfies `Enumerable<DayOfWeek>`, which means that you can\ncreate ranges of days of week:\n\nE.g:\n    value week = monday..sunday;\n    value weekend = saturday..sunday;\n\nNote that ranges created this way are always in _increasing_ order, wrapping\nonce last day of week is reached. This means that when you create a range of `tuesday..monday`,\nthis is equivalent to the following sequence: `[tuesday, wednesday, thursday, friday, saturday, sunday, monday]`\n\nIn order to get the reverse order range, you can use either span operator:\n    value reverseDaysOfWeek = tuesday:-1;\n\nor explicitly reverse the order of the range like this:\n    calue reverseDaysOfWeek = (monday..tuesday).reverse();\n\n"]}],sts:[{md:"$",ta:{"Ordinal.Other":{pk:".",nm:"DayOfWeek"}},pk:"$",nm:"Ordinal"},{md:"$",ta:{"Comparable.Other":{pk:".",nm:"DayOfWeek"}},pk:"$",nm:"Comparable"},{md:"$",ta:{"Enumerable.Other":{pk:".",nm:"DayOfWeek"}},pk:"$",nm:"Enumerable"}],$m:{plusDays:{$t:{pk:".",nm:"DayOfWeek"},pa:1,mt:"m",an:[{doc:["Returns a day of week that comes specified number of days after this DayOfWeek."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"number"}]],nm:"plusDays"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,mt:"m",an:[{doc:["Compare days of week."]}],ps:[[{$t:{pk:".",nm:"DayOfWeek"},mt:"prm",nm:"other"}]],nm:"compare"},neighbour:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"m",an:[{doc:["returns `n`-th neighbour of this _day of week_.\n\nFor example:\n\n    assert(sunday.neighbour(0)  == sunday);\n    assert(sunday.neighbour(1)  == monday);\n    assert(sunday.neighbour(-1) == saturday);\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"neighbour"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:11,mt:"m",an:[{doc:["Returns the offset of the other _day of week_ compared to this.\n\nThis will always return positive integer such that given any\ntwo days of week `a` and `b`, the following is always true:\n\n    assert(0 <= a.offset(b) <= 6);\n"]}],ps:[[{$t:{pk:".",nm:"DayOfWeek"},mt:"prm",nm:"other"}]],nm:"offset"},minusDays:{$t:{pk:".",nm:"DayOfWeek"},pa:1,mt:"m",an:[{doc:["Returns a day of week that comes number of days before this DayOfWeek."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"number"}]],nm:"minusDays"}},$at:{integer:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["Numeric value of the DayOfWeek."]}],nm:"integer"}},ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"prm",an:[{doc:["Numeric value of the DayOfWeek."]}],$hdn:1,nm:"integer"}],nm:"DayOfWeek"},UnitOfHour:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"hours"}],pa:257,mt:"c",sts:[{pk:".",nm:"UnitOfTime"}],nm:"UnitOfHour"},march:{super:{pk:".",nm:"Month"},pa:1,mt:"o",an:[{doc:["March. The third month of a gregorian calendar system."]}],$at:{predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"march"},ReadableInstant:{pa:1,mt:"i",an:[{doc:["An abstraction for data that can represent an instant of time."]},{see:["Instant"]}],$at:{millisecondsOfEpoch:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Internal value of an instant as a number of milliseconds \nsince beginning of an _epoch_ (january 1st 1970 UTC)"]}],nm:"millisecondsOfEpoch"}},nm:"ReadableInstant"},parseDayOfWeek:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"DayOfWeek"}]},pa:1,mt:"m",an:[{doc:["Parses a string into a DayOfWeek.\n\nExpected inputs and outputs are:\n* \"sunday\"    results in [[sunday]]\n* \"monday\"    results in [[monday]]\n* \"tuesday\"   results in [[tuesday]]\n* \"wednesday\" results in [[wednesday]]\n* \"thursday\"  results in [[thursday]]\n* \"friday\"    results in [[friday]]\n* \"saturday\"  results in [[saturday]]"]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"dayOfWeek"}]],nm:"parseDayOfWeek"},january:{super:{pk:".",nm:"Month"},pa:1,mt:"o",an:[{doc:["January. The first month of a gregorian calendar system."]}],$at:{predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"january"},saturday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",an:[{doc:["_Saturday_ is the day of the week that follows Friday and precedes Sunday."]}],$at:{predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"saturday"},july:{super:{pk:".",nm:"Month"},pa:1,mt:"o",an:[{doc:["July. The seventh month of a gregorian calendar system."]}],$at:{predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"july"},friday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",an:[{doc:["_Friday_ is the day of the week that follows Thursday and precedes Saturday."]}],$at:{predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"friday"},YearBehavior:{pa:1,mt:"i",an:[{doc:["Common behavior for year types."]}],tp:[{sts:[{pk:".",nm:"ReadableYear"}],nm:"Element"}],$m:{minusYears:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this instance with the specified number of years subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"minusYears"},plusYears:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this instance with the specified number of years added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"plusYears"},withYear:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this instance with the specified year."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],nm:"withYear"}},nm:"YearBehavior"},UnitOfMonth:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"months"}],pa:257,mt:"c",sts:[{pk:".",nm:"UnitOfDate"}],nm:"UnitOfMonth"},milliseconds:{super:{pk:".",nm:"UnitOfMillisecond"},pa:1,mt:"o",an:[{doc:["Common properties of _millisecond_ time unit."]}],$at:{perMinute:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:[{doc:["Milliseconds per minute."]}],nm:"perMinute"},perSecond:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["Number of milliseconds per second."]}],nm:"perSecond"},perDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:[{doc:["Number of milliseconds per day."]}],nm:"perDay"},perHour:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:[{doc:["Number of milliseconds per hour."]}],nm:"perHour"}},nm:"milliseconds"},ReadableDuration:{pa:1,mt:"i",an:[{doc:["An abstraction of data representing a specific duration of time.\n\nA duration is a fixed delta of time between two instants \nmeasured in number of milliseconds."]},{see:["Duration"]}],$at:{milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Number of milliseconds."]}],nm:"milliseconds"}},nm:"ReadableDuration"},november:{super:{pk:".",nm:"Month"},pa:1,mt:"o",an:[{doc:["November. The eleventh month of a gregorian calendar system."]}],$at:{predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"november"},DateBehavior:{pa:1,mt:"i",an:[{doc:["Common behavior for date types."]}],sts:[{ta:{"YearBehavior.Element":{nm:"Element"}},pk:".",nm:"YearBehavior"},{ta:{"MonthBehavior.Element":{nm:"Element"}},pk:".",nm:"MonthBehavior"}],tp:[{sts:[{pk:".",nm:"ReadableDate"}],nm:"Element"}],$m:{withWeekOfYear:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified week of year."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weekNumber"}]],nm:"withWeekOfYear"},minusWeeks:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of weeks subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],nm:"minusWeeks"},plusDays:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of days added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"plusDays"},plusWeeks:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of weeks added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],nm:"plusWeeks"},withDayOfYear:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified day of year."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfYear"}]],nm:"withDayOfYear"},withDayOfWeek:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified day of week."]}],ps:[[{$t:{pk:".",nm:"DayOfWeek"},mt:"prm",nm:"dayOfWeek"}]],nm:"withDayOfWeek"},minusDays:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of days subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"minusDays"},withDay:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified day of month."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfMonth"}]],nm:"withDay"}},nm:"DateBehavior"},hours:{super:{pk:".",nm:"UnitOfHour"},pa:1,mt:"o",an:[{doc:["Common properties of _hour_ time unit."]}],$at:{perDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["Number of hours per day."]}],nm:"perDay"}},nm:"hours"},thursday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",an:[{doc:["_Thursday_ is the day of the week that follows Wednesday and precedes Friday."]}],$at:{predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"thursday"},monthOf:{$t:{pk:".",nm:"Month"},pa:1,mt:"m",an:[{doc:["Returns month of year specified by the input argument.\n\nIf input is an Integer, this method returns a month according to the integer \nvalue of the [[Month]] (i.e. 1=[[january]], 2=[[february]], ... 12=[[december]])\nAny invalid values will throw an [[AssertionError]].\n\nIf the input value is a [[Month]], the input value is returned as is."]}],ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:".",nm:"Month"}]},mt:"prm",nm:"month"}]],nm:"monthOf"},PeriodBehavior:{of:[{nm:"Self"}],pa:1,mt:"i",an:[{doc:["Common behavior of objects representing a period."]}],sts:[{pk:".",nm:"ReadablePeriod"}],tp:[{sts:[{ta:{"PeriodBehavior.Self":{nm:"Self"}},pk:".",nm:"PeriodBehavior"},{pk:".",nm:"ReadablePeriod"}],nm:"Self"}],st:"Self",$m:{normalized:{$t:{ta:{"PeriodBehavior.Self":{nm:"Self"}},pk:".",nm:"PeriodBehavior"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with all amounts normalized to the \nstandard ranges for date-time fields.\n\nTwo normalizations occur, one for years and months, and one for\nhours, minutes, seconds and nanoseconds.\n\nDays are not normalized, as a day may vary in length at daylight savings cutover.\n\nNeither is days normalized into months, as number of days per month varies from \nmonth to another and depending on the leap year."]}],nm:"normalized"},withMilliseconds:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of milliseconds."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"withMilliseconds"},withYears:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of years."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],nm:"withYears"},minusSeconds:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of seconds subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"minusSeconds"},plusDays:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of days added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"plusDays"},withDays:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of days."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"daysOfMonth"}]],nm:"withDays"},withMinutes:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of minutes."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"withMinutes"},minusMinutes:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of minutes subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"minusMinutes"},minusYears:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of years subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"minusYears"},plusHours:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of hours added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"plusHours"},minusDays:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of days subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],nm:"minusDays"},minusHours:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of hours subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"minusHours"},withMonths:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of months."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"month"}]],nm:"withMonths"},minusMonths:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of months subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"minusMonths"},plusMonths:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of months added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"plusMonths"},plusSeconds:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of seconds added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"plusSeconds"},minusMilliseconds:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of milliseconds subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"minusMilliseconds"},plusMilliseconds:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of milliseconds added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"plusMilliseconds"},plusYears:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of years added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],nm:"plusYears"},withHours:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of hours."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"withHours"},withSeconds:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of seconds."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"withSeconds"},plusMinutes:{$t:{nm:"Self"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of minutes added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"plusMinutes"}},nm:"PeriodBehavior"},UnitOfYear:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"years"}],pa:257,mt:"c",sts:[{pk:".",nm:"UnitOfDate"}],nm:"UnitOfYear"},ReadableTimePeriod:{pa:1,mt:"i",an:[{doc:["A period of _hours_, _minutes_, _seconds_ and _milliseconds_."]}],$at:{minutes:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["The number of minutes"]}],nm:"minutes"},seconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["The number of seconds"]}],nm:"seconds"},hours:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["The number of hours"]}],nm:"hours"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["The number of milliseconds"]}],nm:"milliseconds"}},nm:"ReadableTimePeriod"},DateTimeBehavior:{pa:1,mt:"i",an:[{doc:["Common behavior of the [[DateTime]] types."]},{see:["DateTime","ReadableDateTime","ReadableDate","ReadableTime"]}],sts:[{ta:{"DateBehavior.Element":{nm:"Element"}},pk:".",nm:"DateBehavior"},{ta:{"TimeBehavior.Element":{nm:"Element"}},pk:".",nm:"TimeBehavior"}],tp:[{sts:[{pk:".",nm:"ReadableDateTime"}],nm:"Element"},{dv:"out",sts:[{pk:".",nm:"ReadableDate"}],nm:"DateType"},{dv:"out",sts:[{pk:".",nm:"ReadableTime"}],nm:"TimeType"}],$at:{time:{$t:{nm:"TimeType"},pa:5,mt:"a",an:[{doc:["Returns Time portion of this [[DateTime]] value."]}],nm:"time"},date:{$t:{nm:"DateType"},pa:5,mt:"a",an:[{doc:["Returns Date portion of this [[DateTime]] value."]}],nm:"date"}},nm:"DateTimeBehavior"},december:{super:{pk:".",nm:"Month"},pa:1,mt:"o",an:[{doc:["December. The twelfth (last) month of a gregorian calendar system."]}],$at:{predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"december"},february:{super:{pk:".",nm:"Month"},pa:1,mt:"o",an:[{doc:["February. The second month of a gregorian calendar system."]}],$at:{predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"february"},sunday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",an:[{doc:["_Sunday_ is the day of the week that follows Saturday and precedes Monday."]}],$at:{predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"sunday"},ReadablePeriod:{pa:1,mt:"i",an:[{doc:["A Period of time represented as number of _years_, _months_, _days_, \n_hours_, _minutes_, _seconds_ and\/or _milliseconds_."]}],sts:[{pk:".",nm:"ReadableDatePeriod"},{pk:".",nm:"ReadableTimePeriod"}],$at:{dateOnly:{$t:{pk:".",nm:"ReadableDatePeriod"},pa:5,mt:"a",an:[{doc:["Returns a truncated view of this period that only contains number of \n_years_, _months_ and _days_."]}],nm:"dateOnly"},timeOnly:{$t:{pk:".",nm:"ReadableTimePeriod"},pa:5,mt:"a",an:[{doc:["Returns a truncated view of this period that only contains number of \n_hours_, _minutes_, _seconds_ and _milliseconds_."]}],nm:"timeOnly"}},nm:"ReadablePeriod"},firstDayOfMonth:{$t:{md:"$",ta:{"Sequential.Element":{md:"$",pk:"$",nm:"Integer"}},pk:"$",nm:"Sequential"},mt:"a",an:[{doc:["Table of _day of year_ values for the first day of each month."]}],nm:"firstDayOfMonth"},years:{super:{pk:".",nm:"UnitOfYear"},pa:1,mt:"o",an:[{doc:["Common properties and constraints of _year_ unit."]}],$at:{minimum:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["The minimum supported year for instances of `Date`, -283_457."]}],nm:"minimum"},maximum:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["The maximum supported year for instances of `Date`, 999,999,999."]}],nm:"maximum"}},nm:"years"},ReadableDateTime:{pa:1,mt:"i",an:[{doc:["Common interface that can represent particular time of day on a specific date."]}],sts:[{pk:".",nm:"ReadableDate"},{pk:".",nm:"ReadableTime"}],nm:"ReadableDateTime"},UnitOfTime:{of:[{pk:".",nm:"UnitOfHour"},{pk:".",nm:"UnitOfMinute"},{pk:".",nm:"UnitOfSecond"},{pk:".",nm:"UnitOfMillisecond"}],pa:1,mt:"i",an:[{doc:["Represents units of Time"]}],nm:"UnitOfTime"},june:{super:{pk:".",nm:"Month"},pa:1,mt:"o",an:[{doc:["June. The sixth month of a gregorian calendar system."]}],$at:{predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"june"},UnitOfDate:{of:[{pk:".",nm:"UnitOfYear"},{pk:".",nm:"UnitOfMonth"},{pk:".",nm:"UnitOfDay"}],pa:1,mt:"i",an:[{doc:["Represents units of Date"]}],nm:"UnitOfDate"},ReadableMonth:{pa:1,mt:"i",an:[{doc:["A common interface of all month like objects.\n\nThis interface is common to all data types that\neither partially or fully represent information \nthat can be interpreted as _month_."]},{see:["Date","DateTime","ZoneDateTime"]}],$at:{month:{$t:{pk:".",nm:"Month"},pa:5,mt:"a",an:[{doc:["Month of the year value of the date."]}],nm:"month"}},nm:"ReadableMonth"},weekdays:{$t:{md:"$",ta:{"Sequential.Element":{pk:".",nm:"DayOfWeek"}},pk:"$",nm:"Sequential"},pa:1,mt:"a",an:[{doc:["List of all available weekdays."]}],nm:"weekdays"},ReadableDate:{pa:1,mt:"i",an:[{doc:["A common interface of all date like objects.\n\nThis interface is common to all data types that\neither partially or fully represent information \nthat can be interpreted as _date_."]},{see:["Date","Time","DateTime","ZoneDateTime"]}],sts:[{pk:".",nm:"ReadableYear"},{pk:".",nm:"ReadableMonth"}],$at:{dayOfEra:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Number of calendar days since ERA."]}],nm:"dayOfEra"},weekOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Number of the week of the date."]}],nm:"weekOfYear"},day:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Day of month value of the date."]}],nm:"day"},dayOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["Number of the day in year."]}],nm:"dayOfYear"},dayOfWeek:{$t:{pk:".",nm:"DayOfWeek"},pa:5,mt:"a",an:[{doc:["Day of the week."]}],nm:"dayOfWeek"}},nm:"ReadableDate"},UnitOfMillisecond:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"milliseconds"}],pa:257,mt:"c",sts:[{pk:".",nm:"UnitOfTime"}],nm:"UnitOfMillisecond"},ReadableYear:{pa:1,mt:"i",an:[{doc:["A common interface of all year like objects.\n\nThis interface is common to all data types that\neither partially or fully represent information \nthat can be interpreted as _year_."]},{see:["Date","DateTime","ZoneDateTime"]}],$at:{year:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["The year of the date."]}],nm:"year"},leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:5,mt:"a",an:[{doc:["True if the year of the date is a leap year."]}],nm:"leapYear"}},nm:"ReadableYear"},august:{super:{pk:".",nm:"Month"},pa:1,mt:"o",an:[{doc:["August. The eighth month of a gregorian calendar system."]}],$at:{predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"august"},ReadableDatePeriod:{pa:1,mt:"i",an:[{doc:["A period of _days_, _months_ and _years_."]}],$at:{months:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["The number of months."]}],nm:"months"},days:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["The number of days."]}],nm:"days"},years:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:[{doc:["The number of years."]}],nm:"years"}},nm:"ReadableDatePeriod"},UnitOfDay:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"days"}],pa:257,mt:"c",sts:[{pk:".",nm:"UnitOfDate"}],nm:"UnitOfDay"},tuesday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",an:[{doc:["_Tuesday_ is the day of the week that follows Monday and precedes Wednesday."]}],$at:{predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"tuesday"},"$pkg-pa":1,dayOfWeek:{$t:{pk:".",nm:"DayOfWeek"},pa:1,mt:"m",an:[{doc:["Returns [[DayOfWeek]] from the input."]}],ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:".",nm:"DayOfWeek"}]},mt:"prm",nm:"dayOfWeek"}]],nm:"dayOfWeek"},september:{super:{pk:".",nm:"Month"},pa:1,mt:"o",an:[{doc:["September. The ninth month of a gregorian calendar system."]}],$at:{predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"september"},may:{super:{pk:".",nm:"Month"},pa:1,mt:"o",an:[{doc:["May. The fifth month of a gregorian calendar system."]}],$at:{predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"may"},Range:{pa:1,mt:"i",an:[{doc:["An interface to represent a Range between same kinds of _Date_ or _DateTime_ or _Time_."]}],sts:[{md:"$",ta:{"Iterable.Absent":{md:"$",pk:"$",nm:"Null"},"Iterable.Element":{nm:"Element"}},pk:"$",nm:"Iterable"}],tp:[{sts:[{md:"$",ta:{"Enumerable.Other":{nm:"Element"}},pk:"$",nm:"Enumerable"}],nm:"Element"},{nm:"StepBy"}],$m:{overlap:{$t:{comp:"u",l:[{ta:{"Range.Element":{nm:"Element"},"Range.StepBy":{nm:"StepBy"}},pk:".",nm:"Range"},{md:"$",pk:"$",nm:"Empty"}]},pa:5,mt:"m",an:[{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A]\n- The precision is based on the lowest unit\n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB < CD\n\n    [1..6] overlap [3..9] = [3,6]\n\n    [1..6] overlap [9..3] = [3,6]\n\n    [6..1] overlap [3..9] = [3,6]\n\n    [6..1] overlap [9..3] = [3,6]\n\n\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB > CD\n\n    [3..9] overlap [1..6] = [3,6]\n\n    [3..9] overlap [6..1] = [3,6]\n\n    [9..3] overlap [1..6] = [3,6]\n\n    [9..3] overlap [6..1] = [3,6]"]}],ps:[[{$t:{ta:{"Range.Element":{nm:"Element"},"Range.StepBy":{nm:"StepBy"}},pk:".",nm:"Range"},mt:"prm",nm:"other"}]],nm:"overlap"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:11,mt:"m",an:[{doc:["Returns true if both: this and other are same type and have equal fields _from_ and _to_."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],nm:"equals"},stepBy:{$t:{ta:{"Range.Element":{nm:"Element"},"Range.StepBy":{nm:"StepBy"}},pk:".",nm:"Range"},pa:5,mt:"m",an:[{doc:["Define how this Range will get next or previous element while iterating."]}],ps:[[{$t:{nm:"StepBy"},mt:"prm",nm:"step"}]],nm:"stepBy"},gap:{$t:{comp:"u",l:[{ta:{"Range.Element":{nm:"Element"},"Range.StepBy":{nm:"StepBy"}},pk:".",nm:"Range"},{md:"$",pk:"$",nm:"Empty"}]},pa:5,mt:"m",an:[{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A] \n- The precision is based on the lowest unit \n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB < CD\n\n    [1..2] gap [5..6] = (2,5)\n\n    [1..2] gap [6..5] = (2,5)\n\n    [2..1] gap [5..6] = (2,5)\n\n    [2..1] gap [6..5] = (2,5)\n\n\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB > CD\n\n    [5..6] gap [1..2] = (2,5)\n\n    [5..6] gap [2..1] = (2,5)\n\n    [6..5] gap [1..2] = (2,5)\n\n    [6..5] gap [2..1] = (2,5)"]}],ps:[[{$t:{ta:{"Range.Element":{nm:"Element"},"Range.StepBy":{nm:"StepBy"}},pk:".",nm:"Range"},mt:"prm",nm:"other"}]],nm:"gap"}},$at:{to:{$t:{nm:"Element"},pa:5,mt:"a",an:[{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]}],nm:"to"},duration:{$t:{pk:"ceylon.time",nm:"Duration"},pa:5,mt:"a",an:[{doc:["Returns the Duration between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 86400000 milliseconds.\n\nGiven: tomorrow().to(today).duration then duration is -86400000 milliseconds."]}],nm:"duration"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:11,mt:"g",an:[{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]}],nm:"hash"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:11,mt:"g",an:[{doc:["Returns ISO-8601 formatted String representation of this Range.\n\nReference: https:\/\/en.wikipedia.org\/wiki\/ISO_8601#Time_intervals"]}],nm:"string"},from:{$t:{nm:"Element"},pa:5,mt:"a",an:[{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]}],nm:"from"},period:{$t:{pk:"ceylon.time",nm:"Period"},pa:5,mt:"a",an:[{doc:["Returns the Period between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 1 day.\n\nGiven: tomorrow().to(today).duration then duration is -1 day."]}],nm:"period"},step:{$t:{comp:"u",l:[{pk:".",nm:"UnitOfDate"},{pk:".",nm:"UnitOfTime"}]},pa:5,mt:"a",an:[{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]}],nm:"step"}},nm:"Range"},minutes:{super:{pk:".",nm:"UnitOfMinute"},pa:1,mt:"o",an:[{doc:["Common properties of _minute_ time unit."]}],$at:{perDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:[{doc:["Number of minutes per day."]}],nm:"perDay"},perHour:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["Number of minutes per hour."]}],nm:"perHour"}},nm:"minutes"},april:{super:{pk:".",nm:"Month"},pa:1,mt:"o",an:[{doc:["April. The fourth month of a gregorian calendar system."]}],$at:{predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"april"},UnitOfSecond:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"seconds"}],pa:257,mt:"c",sts:[{pk:".",nm:"UnitOfTime"}],nm:"UnitOfSecond"},MonthBehavior:{pa:1,mt:"i",an:[{doc:["Common behavior for month types."]}],tp:[{sts:[{pk:".",nm:"ReadableMonth"}],nm:"Element"}],$m:{minusMonths:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this instance with the specified number of months subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"minusMonths"},plusMonths:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this instance with the specified number of months added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],nm:"plusMonths"},withMonth:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this instance with the specified month of year."]}],ps:[[{$t:{pk:".",nm:"Month"},mt:"prm",nm:"month"}]],nm:"withMonth"}},nm:"MonthBehavior"},months:{super:{pk:".",nm:"UnitOfMonth"},pa:1,mt:"o",an:[{doc:["Common properties and constraints of months."]}],$m:{valueOf:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Month"}]},pa:1,mt:"m",an:[{doc:["Returns month with the specified ordinal number or `null` if provided number is not a valid month number."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"number"}]],nm:"valueOf"}},$at:{perYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["Number of months per year."]}],nm:"perYear"},all:{$t:{md:"$",ta:{"Sequential.Element":{pk:".",nm:"Month"}},pk:"$",nm:"Sequential"},pa:1,mt:"a",an:[{doc:["Ordered list of all months of Gregorian and Julian calendar system from January to December."]}],nm:"all"}},nm:"months"},wednesday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",an:[{doc:["_Wednesday_ is the day of the week that follows Tuesday and precedes Thursday."]}],$at:{predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"wednesday"},days:{super:{pk:".",nm:"UnitOfDay"},pa:1,mt:"o",an:[{doc:["Common properties and constraints of _day_ unit."]}],$m:{toMonth:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns the number of days from the start of the year to the first of the month."]}],ps:[[{$t:{pk:".",nm:"Month"},mt:"prm",nm:"month"},{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"leapYear"}]],nm:"toMonth"},fromMilliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns number of days from the number of milliseconds."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"millisecondsIn"}]],nm:"fromMilliseconds"},perMonth:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"m",an:[{doc:["Returns the number of days per month."]}],ps:[[{$t:{pk:".",nm:"Month"},mt:"prm",nm:"month"},{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"leapYear"}]],nm:"perMonth"}},$at:{inFourYears:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["Number of days in four years."]}],nm:"inFourYears"},perYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:[{doc:["Number of days per normal year."]}],nm:"perYear"},ofWeek:{$t:{md:"$",ta:{"Sequential.Element":{pk:".",nm:"DayOfWeek"}},pk:"$",nm:"Sequential"},pa:1,mt:"a",nm:"ofWeek"},perCentury:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["Number of of per century (100 years)."]}],nm:"perCentury"},perFourCenturies:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:[{doc:["The number of days in a 400 year cycle."]}],nm:"perFourCenturies"},perLeapYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:[{doc:["Number of days per leap year."]}],nm:"perLeapYear"},perCycle:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["The number of days in a 400 year cycle."]}],nm:"perCycle"},perWeek:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["Number of days per week (7)."]}],nm:"perWeek"}},nm:"days"},seconds:{super:{pk:".",nm:"UnitOfSecond"},pa:1,mt:"o",an:[{doc:["Common properties of _second_ time unit."]}],$at:{perMinute:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:[{doc:["Number of seconds per minute."]}],nm:"perMinute"},perDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:[{doc:["Number of seconds per day."]}],nm:"perDay"},perHour:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:[{doc:["Number of seconds per hour."]}],nm:"perHour"}},nm:"seconds"},october:{super:{pk:".",nm:"Month"},pa:1,mt:"o",an:[{doc:["October. The tenth month of a gregorian calendar system."]}],$at:{predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"},successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},nm:"october"},UnitOfMinute:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"minutes"}],pa:257,mt:"c",sts:[{pk:".",nm:"UnitOfTime"}],nm:"UnitOfMinute"},"$pkg-anns":[{doc:["Base classes and interfaces of the Date\/Time library."]},{by:["Diego Coronel","Roland Tepp"]}],TimeBehavior:{pa:1,mt:"i",an:[{doc:["Common behavior for the types that represent time."]}],tp:[{sts:[{pk:".",nm:"ReadableTime"}],nm:"Element"}],$m:{minusHours:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of hours subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"minusHours"},withMilliseconds:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of milliseconds."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"withMilliseconds"},minusSeconds:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of seconds subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"minusSeconds"},withMinutes:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of minutes."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"withMinutes"},plusSeconds:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of seconds added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"plusSeconds"},minusMilliseconds:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of milliseconds subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"minusMilliseconds"},minusMinutes:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of minutes subtracted."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"minusMinutes"},plusMilliseconds:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of milliseconds added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],nm:"plusMilliseconds"},withHours:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of hours.\n\nResult must be a valid time of day."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"withHours"},withSeconds:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified amount of seconds."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],nm:"withSeconds"},plusMinutes:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of minutes added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],nm:"plusMinutes"},plusHours:{$t:{nm:"Element"},pa:5,mt:"m",an:[{doc:["Returns a copy of this period with the specified number of hours added."]}],ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],nm:"plusHours"}},nm:"TimeBehavior"}},"$mod-bin":"10.0","ceylon.time.iso8601":{createDateTime:{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"m",ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"date"},{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}]],nm:"createDateTime"},parseWeek:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"parseWeek"},parseTimeZone:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time.timezone",nm:"TimeZone"}]},pa:1,mt:"m",an:[{doc:["Timezone offset parser based on ISO-8601, currently it accepts the following \ntime zone offset patterns:\n\n- &plusmn;`[hh]:[mm]`,\n- &plusmn;`[hh][mm]`, and \n- &plusmn;`[hh]`.\n\nIn addition, the special code `Z` is recognized as a shorthand for `+00:00`"]}],$m:{offsetTimeZone$mf7brt:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time.timezone",nm:"OffsetTimeZone"}]},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hh"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"mm"}]],nm:"offsetTimeZone"}},ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"offset"}]],nm:"parseTimeZone"},parsePeriod:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time",nm:"Period"}]},pa:1,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"parsePeriod"},parseInteger:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"parseInteger"},parseDateTime:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time",nm:"DateTime"}]},pa:1,mt:"m",an:[{doc:["The [[DateTime]] value of the given [[string representation|String]] \nof a [ISO 8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) datetime format \nor `null` if the string does not contain valid ISO 8601 formatted \ndatetime value or the datetime is not formatted according to ISO standard."]},{see:["parseDate","parseTime"]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"input"}]],nm:"parseDateTime"},parseMonth:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time.base",nm:"Month"}]},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"parseMonth"},convertToTime:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time",nm:"Time"}]},mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{count:4,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"}]},mt:"prm",nm:"timeComponents"}]],nm:"convertToTime"},State:{mt:"als",$alias:{md:"$",pk:"$",nm:"Integer"},nm:"State"},parseZoneDateTime:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time.timezone",nm:"ZoneDateTime"}]},pa:1,mt:"m",an:[{doc:["The [[ZoneDateTime]] value of the given [[string representation|String]] \nof a [ISO 8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) zoned datetime \nformat or `null` if the string does not contain valid ISO 8601 formatted \nzoned datetime value or the datetime is not formatted according to ISO \nstandard."]},{see:["parseDate","parseTime","parseTimeZone"]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"input"}]],nm:"parseZoneDateTime"},parseTime:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time",nm:"Time"}]},pa:1,mt:"m",an:[{doc:["The [[Time]] value of the given [[string representation|String]] \nof a [ISO 8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) date format \nor `null` if the string does not contain valid ISO 8601 formatted \ndate value or the date is not formatted according to ISO standard.\n\nMore specifically, this method parses any input that conforms to any \nof the following date formats:\n\n- `hh:mm:ss.sss` (or `hhmmss.sss`),\n- `hh:mm:ss` (or `hhmmss`),\n- `hh:mm` (or `hhmm`)\n- and `hh`\n\nWhere `hh` stands for 2 digit 24 hour clock hour value between \n`00` and `24` (where `24` is only used to denote midnight at the \nend of a calendar day)\n\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"input"}]],nm:"parseTime"},parseDayOfMonth:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"},{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],nm:"parseDayOfMonth"},parseYear:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"parseYear"},parseTimeComponents:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{count:4,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"}]},mt:"m",$m:{fractionalMinutes$n7s8ug:{$t:{count:4,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hh"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"mm"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"ms"}]],nm:"fractionalMinutes"},fractionalHours$eqop0o:{$t:{count:4,$t:{md:"$",pk:"$",nm:"Integer"},pk:"$",nm:"Tuple"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hh"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"ms"}]],nm:"fractionalHours"},calculateFraction$k42vha:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Null"}]},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"magnitude"},{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"fractionPart"}]],nm:"calculateFraction"},parseMilliseconds$4qjv03:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Null"}]},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"fractionPart"}]],nm:"parseMilliseconds"}},ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"input"}]],nm:"parseTimeComponents"},"$pkg-pa":1,"$pkg-anns":[{doc:["This package contains parsers implementations for reading [[ceylon.time::Date]], \n[[ceylon.time::Time]], [[ceylon.time::DateTime]], [[ceylon.time.timezone::TimeZone]], and\n[[ceylon.time.timezone::ZoneDateTime]] values from their [ISO 8601][1] formatted string \nrepresentations.\n\nThe parser functions are [[parseDate]], [[parseTime]], [[parseDateTime]], [[parseTimeZone]],\nand [[parseZoneDateTime]].\n\nThis package only contains parsers for reading `Date`, `Time`, `DateTime` and `Period` values from their \n[[string representation|String]] forms. There are no formatters in this package, as all relevant types return \nISO 8601 formatted values as their `string` attribute.\n\nIf you need more flexible, locale aware parsing and formatting facilities, look into `ceylon.locale` package.\n\n[1]: https:\/\/en.wikipedia.org\/wiki\/ISO_8601"]},{by:["Roland Tepp"]}],parseDate:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time",nm:"Date"}]},pa:1,mt:"m",an:[{doc:["The [[Date]] value of the given [[string representation|String]] \nof a [ISO 8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) date format \nor `null` if the string does not contain valid ISO 8601 formatted \ndate value or the date is not formatted according to ISO standard.\n\nMore specifically, this method parses any input that conforms to any of the \nfollowing date formats:\n\n- `YYYY-MM-DD` or `YYYYMMDD`\n- `YYYY-Www-D` or `YYYYWwwD`\n- `YYYY-DDD`   or `YYYYDDD`\n \n \nWhere: `YYYY` stands for a full (four digit) year number,\n`MM` is a number of a month of year (ranging from `01` for January to `12` for December),\n`DD` is a number of a day of month (ranging from `01` to `31`),\n`Www` stands for a single uppercase character `'W'` followed by two digit number of a week (ranging from `01` to `53`)\nand `D` stands for a single digit day of week.\n\n**Note:** This function accepts only four digit full year date formats. \nThere is no support for abbreviated 2 digit format or year values larger than 4 digits.\n"]}],ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"input"}]],nm:"parseDate"},parseDay:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],nm:"parseDay"}}};
});
}(typeof define==='function' && define.amd ? define : function (factory) {
if (typeof exports!=='undefined') { factory(require, exports, module);
} else { throw 'no module loader'; }
}));
